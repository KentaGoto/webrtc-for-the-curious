<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Applied WebRTC #  Now that you know how WebRTC works it is time to build with it. This chapter explores what people are building with WebRTC, and how they are building it. You will learn all the interesting things that are happening with WebRTC. The power of WebRTC comes as a cost. Building production grade WebRTC services is challenging. This chapter will try and explain those challenges before you hit them."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Applied WebRTC"><meta property="og:description" content="Applied WebRTC #  Now that you know how WebRTC works it is time to build with it. This chapter explores what people are building with WebRTC, and how they are building it. You will learn all the interesting things that are happening with WebRTC. The power of WebRTC comes as a cost. Building production grade WebRTC services is challenging. This chapter will try and explain those challenges before you hit them."><meta property="og:type" content="article"><meta property="og:url" content="https://webrtcforthecurious.com/docs/08-applied-webrtc/"><meta property="article:modified_time" content="2021-03-28T18:05:10-07:00"><meta property="og:site_name" content="WebRTC for the Curious"><title>Applied WebRTC | WebRTC for the Curious</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=alternate hreflang=tr href=https://webrtcforthecurious.com/tr/docs/08-applied-webrtc/ title="Applied WebRTC"><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/08-applied-webrtc/ title=WebRTC应用场景><link rel=stylesheet href=/book.min.6cd8553a6854f4812343f0f0c8baca31271e686434f381fbe3c7226f66639176.css integrity="sha256-bNhVOmhU9IEjQ/DwyLrKMSceaGQ084H748cib2ZjkXY="><script defer src=/en.search.min.f2b728508cbf4e2362d6d3492cb3e5986b55cbe40173dbc9797fa729d334d1db.js integrity="sha256-8rcoUIy/TiNi1tNJLLPlmGtVy+QBc9vJeX+nKdM00ds="></script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/><span>WebRTC for the Curious</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/docs/01-what-why-and-how/>What, Why and How</a></li><li><a href=/docs/02-signaling/>Signaling</a></li><li><a href=/docs/03-connecting/>Connecting</a></li><li><a href=/docs/04-securing/>Securing</a></li><li><a href=/docs/05-real-time-networking/>Real-time Networking</a></li><li><a href=/docs/06-media-communication/>Media Communication</a></li><li><a href=/docs/07-data-communication/>Data Communication</a></li><li><a href=/docs/08-applied-webrtc/ class=active>Applied WebRTC</a></li><li><a href=/docs/09-debugging/>Debugging</a></li><li><a href=/docs/10-history-of-webrtc/>History</a></li><li><a href=/docs/11-faq/>FAQ</a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Applied WebRTC</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#by-use-case>By Use Case</a><ul><li><a href=#conferencing>Conferencing</a></li><li><a href=#broadcasting>Broadcasting</a></li><li><a href=#remote-access>Remote Access</a></li><li><a href=#file-transfer-and-censorship-circumvention>File-Transfer and Censorship Circumvention</a></li><li><a href=#distributed-cdn>Distributed CDN</a></li><li><a href=#iot>IoT</a></li><li><a href=#media-protocol-bridging>Media Protocol Bridging</a></li><li><a href=#data-protocol-bridging>Data Protocol Bridging</a></li><li><a href=#robotics>Robotics</a></li></ul></li><li><a href=#webrtc-topologies>WebRTC Topologies</a><ul><li><a href=#peer-to-peer>Peer-To-Peer</a></li><li><a href=#client-server>Client-Server</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=applied-webrtc>Applied WebRTC
<a class=anchor href=#applied-webrtc>#</a></h1><p>Now that you know how WebRTC works it is time to build with it. This chapter explores what people are
building with WebRTC, and how they are building it. You will learn all the interesting things that are
happening with WebRTC. The power of WebRTC comes as a cost. Building production grade WebRTC services is
challenging. This chapter will try and explain those challenges before you hit them.</p><h2 id=by-use-case>By Use Case
<a class=anchor href=#by-use-case>#</a></h2><p>Many think WebRTC is just the technology conferencing in the web browser. It is so much more then that though!
WebRTC is used for a wide range of use cases. New use cases showing up all the time. These are some of the common ones.</p><h3 id=conferencing>Conferencing
<a class=anchor href=#conferencing>#</a></h3><p>Conferencing is the original use case for WebRTC. The protocol contains a few necessary features that no other protocol offers
in the browser. You could build a conferencing system with WebSockets and it may work in optimal conditions. If you want
something that can be deployed in real world network conditions WebRTC is the best choice.</p><p>WebRTC provides congestion control and adaptive bitrate for media. As the conditions of the network change users will still get the
best experience possible. Developers don&rsquo;t have to write any additional code to measure these conditions either.</p><p>Participants can send and receive multiple streams. They can also add and remove those streams at any time. Codecs are negotiated
as well. All of this functionality is provided by the browser, no custom code is required to be written by the developer.</p><p>Conferencing also benefits from data channels. Users can send metadata or share documents. You can create multiple streams
and configure them if you need performance more then reliability.</p><h3 id=broadcasting>Broadcasting
<a class=anchor href=#broadcasting>#</a></h3><p>Lots of new projects are starting to appear in the broadcast space that use WebRTC. The protocol has a lot to offer for both the publisher
and consumer of media.</p><p>WebRTC being in the browser makes for it easy for users to publish video. It removes the requirement for users to download a new client.
Any platform that has a web browser can publish video. Publishers can then send multiple tracks and modify/remove them at anytime. This is
a huge improvement over legacy protocols that only allowed one audio/one video track per connection.</p><p>WebRTC gives developers greater control over the latency/quality trade-offs. It could be more important that latency never exceeds a
certain threshold, and you are willing to tolerate some decoding artifacts. You can configure the viewer to play media as soon as it
arrives. With other protocols that run over TCP that isn&rsquo;t as easy. In the browser you can request data and that is it.</p><h3 id=remote-access>Remote Access
<a class=anchor href=#remote-access>#</a></h3><p>Remote Access is when you remotely access another computer via WebRTC. You could have complete control of the remote host, or maybe just a
single application. This is great for running computationally tasks when the local hardware can&rsquo;t do it. Like running a new video game, or
CAD software. WebRTC was able to revolutionize the space in three ways.</p><p>WebRTC can be used to remotely access a host that isn&rsquo;t world routable. With NAT Traversal you can access a computer that is only available
via STUN. This is great for security and privacy. Your users don&rsquo;t have to route video through a ingest or &lsquo;jump box&rsquo;. NAT Traversal also
makes deployments easier. You don&rsquo;t have to worry about port forwarding or setting up a static IP ahead of time.</p><p>Data channels are really powerful as well in this scenario. They can be configured so that only the latest data is accepted. With TCP run the
risk of encountering Head-of-line blocking. A old mouse click or keypress could arrive late, and block the subsequent ones from being accepted.
WebRTC&rsquo;s data channels are designed to handle this and can be configured to not retry on lost packets. You can also measure the backpressure and
make sure that you aren&rsquo;t sending more data then your network supports.</p><p>WebRTC being available in the browser has been a huge quality of life improvement. You don&rsquo;t have to download a proprietary client to start the
session. More and more clients are coming with WebRTC bundled, smart TVs are getting full web browsers now.</p><h3 id=file-transfer-and-censorship-circumvention>File-Transfer and Censorship Circumvention
<a class=anchor href=#file-transfer-and-censorship-circumvention>#</a></h3><h3 id=distributed-cdn>Distributed CDN
<a class=anchor href=#distributed-cdn>#</a></h3><h3 id=iot>IoT
<a class=anchor href=#iot>#</a></h3><p>When a video doorbell detects movement, it could supply the cameras RTP stream and initiated a new <code>PeerConnection</code> with a central server
for recording or send a push notification to a mobile device to ask it to connect as a peer. This would establish a real-time communication
between the front door and the mobile app. The mobile app could send real time audio back to the doorbell or it could initiate secure remote
controls over WebRTC.</p><h3 id=media-protocol-bridging>Media Protocol Bridging
<a class=anchor href=#media-protocol-bridging>#</a></h3><h3 id=data-protocol-bridging>Data Protocol Bridging
<a class=anchor href=#data-protocol-bridging>#</a></h3><h3 id=robotics>Robotics
<a class=anchor href=#robotics>#</a></h3><h2 id=webrtc-topologies>WebRTC Topologies
<a class=anchor href=#webrtc-topologies>#</a></h2><p>WebRTC is a protocol for connecting two agents, so how are developers connecting hundreds of people at once? There are a few different
ways you can do it and they all have pros and cons.</p><h3 id=peer-to-peer>Peer-To-Peer
<a class=anchor href=#peer-to-peer>#</a></h3><h4 id=one-to-one>One-To-One
<a class=anchor href=#one-to-one>#</a></h4><h4 id=p2p-mesh>P2P Mesh
<a class=anchor href=#p2p-mesh>#</a></h4><h3 id=client-server>Client-Server
<a class=anchor href=#client-server>#</a></h3><p>The low-latency nature of WebRTC protocol is great for calls, and it&rsquo;s common to see conferences arranged in p2p mesh configuration
(for low latency), or peering through an SFU (Selective Forwarding Unit) to improve call quality. Since codec support varies by browser,
many conferencing servers allow browsers to broadcast using proprietary or non-free codecs like h264, and then re-encode to an open standard
like VP8 at the server level; when the SFU performs an encoding task beyond just forwarding packets, it is now called an MCU (Multi-point Conferencing Unit).
While SFU are notoriously fast and efficient and great for conferences, MCU can be very resource intensive! Some conferencing servers even
perform heavy tasks like compositing (combining together) A/V streams, customized for each caller, to minimize client bandwidth use by
sending only a single stream of all the other callers.</p><h4 id=sfu-selective-forwarding-unit>SFU (Selective Forwarding Unit)
<a class=anchor href=#sfu-selective-forwarding-unit>#</a></h4><h4 id=mcu-multi-point-conferencing-unit>MCU (Multi-point Conferencing Unit)
<a class=anchor href=#mcu-multi-point-conferencing-unit>#</a></h4></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div class=book-languages tabindex=0 aria-haspopup=true><ul><li class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
English</li></ul><ul class=book-languages-list><li class=active><a href=https://webrtcforthecurious.com/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
English</a></li><li><a href=https://webrtcforthecurious.com/tr/docs/08-applied-webrtc/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Turkish</a></li><li><a href=https://webrtcforthecurious.com/fa/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Persian</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/08-applied-webrtc/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
简体中文</a></li></ul></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/679aa2c446ba3db8af980c3e289c51944a4013b5 title="Last modified by Sean DuBois | March 29, 2021" target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>March 29, 2021</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content//docs/08-applied-webrtc.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#by-use-case>By Use Case</a><ul><li><a href=#conferencing>Conferencing</a></li><li><a href=#broadcasting>Broadcasting</a></li><li><a href=#remote-access>Remote Access</a></li><li><a href=#file-transfer-and-censorship-circumvention>File-Transfer and Censorship Circumvention</a></li><li><a href=#distributed-cdn>Distributed CDN</a></li><li><a href=#iot>IoT</a></li><li><a href=#media-protocol-bridging>Media Protocol Bridging</a></li><li><a href=#data-protocol-bridging>Data Protocol Bridging</a></li><li><a href=#robotics>Robotics</a></li></ul></li><li><a href=#webrtc-topologies>WebRTC Topologies</a><ul><li><a href=#peer-to-peer>Peer-To-Peer</a></li><li><a href=#client-server>Client-Server</a></li></ul></li></ul></nav></aside></main></body></html>