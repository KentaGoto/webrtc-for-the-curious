<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Applied WebRTC #  Now that you know how WebRTC works it is time to build with it. This chapter explores what people are building with WebRTC, and how they are building it. You will learn all the interesting things that are happening with WebRTC. The power of WebRTC comes as a cost. Building production grade WebRTC services is challenging. This chapter will try and explain those challenges before you hit them."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Applied WebRTC"><meta property="og:description" content="Applied WebRTC #  Now that you know how WebRTC works it is time to build with it. This chapter explores what people are building with WebRTC, and how they are building it. You will learn all the interesting things that are happening with WebRTC. The power of WebRTC comes as a cost. Building production grade WebRTC services is challenging. This chapter will try and explain those challenges before you hit them."><meta property="og:type" content="article"><meta property="og:url" content="https://webrtcforthecurious.com/docs/08-applied-webrtc/"><meta property="article:modified_time" content="2021-04-01T20:03:51-04:00"><meta property="og:site_name" content="WebRTC for the Curious"><title>Applied WebRTC | WebRTC for the Curious</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=alternate hreflang=tr href=https://webrtcforthecurious.com/tr/docs/08-applied-webrtc/ title="Applied WebRTC"><link rel=alternate hreflang=zh href=https://webrtcforthecurious.com/zh/docs/08-applied-webrtc/ title=WebRTC应用场景><link rel=stylesheet href=/book.min.6cd8553a6854f4812343f0f0c8baca31271e686434f381fbe3c7226f66639176.css integrity="sha256-bNhVOmhU9IEjQ/DwyLrKMSceaGQ084H748cib2ZjkXY="><script defer src=/en.search.min.97044eaa1215eefed69d3ced8f049c7396e2b4afce1c9909edd9737331007c63.js integrity="sha256-lwROqhIV7v7WnTztjwScc5bitK/OHJkJ7dlzczEAfGM="></script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/><span>WebRTC for the Curious</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/docs/01-what-why-and-how/>What, Why and How</a></li><li><a href=/docs/02-signaling/>Signaling</a></li><li><a href=/docs/03-connecting/>Connecting</a></li><li><a href=/docs/04-securing/>Securing</a></li><li><a href=/docs/05-real-time-networking/>Real-time Networking</a></li><li><a href=/docs/06-media-communication/>Media Communication</a></li><li><a href=/docs/07-data-communication/>Data Communication</a></li><li><a href=/docs/08-applied-webrtc/ class=active>Applied WebRTC</a></li><li><a href=/docs/09-debugging/>Debugging</a></li><li><a href=/docs/10-history-of-webrtc/>History</a></li><li><a href=/docs/11-faq/>FAQ</a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Applied WebRTC</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#by-use-case>By Use Case</a><ul><li><a href=#conferencing>Conferencing</a></li><li><a href=#broadcasting>Broadcasting</a></li><li><a href=#remote-access>Remote Access</a></li><li><a href=#file-sharing-and-censorship-circumvention>File Sharing and Censorship Circumvention</a></li><li><a href=#iot>IoT</a></li><li><a href=#media-protocol-bridging>Media Protocol Bridging</a></li><li><a href=#data-protocol-bridging>Data Protocol Bridging</a></li><li><a href=#teleoperation>Teleoperation</a></li><li><a href=#distributed-cdn>Distributed CDN</a></li></ul></li><li><a href=#webrtc-topologies>WebRTC Topologies</a><ul><li><a href=#peer-to-peer>Peer-To-Peer</a></li><li><a href=#client-server>Client-Server</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=applied-webrtc>Applied WebRTC
<a class=anchor href=#applied-webrtc>#</a></h1><p>Now that you know how WebRTC works it is time to build with it. This chapter explores what people are
building with WebRTC, and how they are building it. You will learn all the interesting things that are
happening with WebRTC. The power of WebRTC comes as a cost. Building production grade WebRTC services is
challenging. This chapter will try and explain those challenges before you hit them.</p><h2 id=by-use-case>By Use Case
<a class=anchor href=#by-use-case>#</a></h2><p>Many think WebRTC is just the technology conferencing in the web browser. It is so much more then that though!
WebRTC is used for a wide range of use cases. New use cases showing up all the time. These are some of the common ones
and how WebRTC is revolutionizing them.</p><h3 id=conferencing>Conferencing
<a class=anchor href=#conferencing>#</a></h3><p>Conferencing is the original use case for WebRTC. The protocol contains a few necessary features that no other protocol offers
in the browser. You could build a conferencing system with WebSockets and it may work in optimal conditions. If you want
something that can be deployed in real world network conditions WebRTC is the best choice.</p><p>WebRTC provides congestion control and adaptive bitrate for media. As the conditions of the network change users will still get the
best experience possible. Developers don&rsquo;t have to write any additional code to measure these conditions either.</p><p>Participants can send and receive multiple streams. They can also add and remove those streams at any time. Codecs are negotiated
as well. All of this functionality is provided by the browser, no custom code is required to be written by the developer.</p><p>Conferencing also benefits from data channels. Users can send metadata or share documents. You can create multiple streams
and configure them if you need performance more then reliability.</p><h3 id=broadcasting>Broadcasting
<a class=anchor href=#broadcasting>#</a></h3><p>Lots of new projects are starting to appear in the broadcast space that use WebRTC. The protocol has a lot to offer for both the publisher
and consumer of media.</p><p>WebRTC being in the browser makes for it easy for users to publish video. It removes the requirement for users to download a new client.
Any platform that has a web browser can publish video. Publishers can then send multiple tracks and modify/remove them at anytime. This is
a huge improvement over legacy protocols that only allowed one audio/one video track per connection.</p><p>WebRTC gives developers greater control over the latency/quality trade-offs. It could be more important that latency never exceeds a
certain threshold, and you are willing to tolerate some decoding artifacts. You can configure the viewer to play media as soon as it
arrives. With other protocols that run over TCP that isn&rsquo;t as easy. In the browser you can request data and that is it.</p><h3 id=remote-access>Remote Access
<a class=anchor href=#remote-access>#</a></h3><p>Remote Access is when you remotely access another computer via WebRTC. You could have complete control of the remote host, or maybe just a
single application. This is great for running computationally tasks when the local hardware can&rsquo;t do it. Like running a new video game, or
CAD software. WebRTC was able to revolutionize the space in three ways.</p><p>WebRTC can be used to remotely access a host that isn&rsquo;t world routable. With NAT Traversal you can access a computer that is only available
via STUN. This is great for security and privacy. Your users don&rsquo;t have to route video through a ingest or &lsquo;jump box&rsquo;. NAT Traversal also
makes deployments easier. You don&rsquo;t have to worry about port forwarding or setting up a static IP ahead of time.</p><p>Data channels are really powerful as well in this scenario. They can be configured so that only the latest data is accepted. With TCP run the
risk of encountering Head-of-line blocking. A old mouse click or keypress could arrive late, and block the subsequent ones from being accepted.
WebRTC&rsquo;s data channels are designed to handle this and can be configured to not retry on lost packets. You can also measure the backpressure and
make sure that you aren&rsquo;t sending more data then your network supports.</p><p>WebRTC being available in the browser has been a huge quality of life improvement. You don&rsquo;t have to download a proprietary client to start the
session. More and more clients are coming with WebRTC bundled, smart TVs are getting full web browsers now.</p><h3 id=file-sharing-and-censorship-circumvention>File Sharing and Censorship Circumvention
<a class=anchor href=#file-sharing-and-censorship-circumvention>#</a></h3><p>File Sharing and Censorship Circumvention are dramatically different problems. However, WebRTC solves the same problems for them both. It makes
them both easily available and harder to block.</p><p>The first problem that WebRTC solves is getting the client. If you want to join a file sharing network you need to download the client. Even if
the network is distributed, you still need to get the client first. In a restricted network the download will often be blocked. Even if you
can download it the user may not be able to install/run the client. WebRTC is available in every web browser already making it readily available.</p><p>The second problem that WebRTC solves is your traffic being blocked. If you use a protocol that is just for file sharing or censorship circumvention
it is much easier to block it. Since WebRTC is a general purpose protocol blocking it would impact everyone. Blocking WebRTC might prevent other
users of the network from joining conference calls.</p><h3 id=iot>IoT
<a class=anchor href=#iot>#</a></h3><p>IoT covers a few different use cases. For many this means network connected security cameras. Using WebRTC you can stream the video to another WebRTC
peer like your a phone or browser. Another use case is having devices connect and exchange sensor data. You can have two devices in your LAN
exchange climate, noise or light readings.</p><p>WebRTC has a huge privacy advantage here over legacy video stream protocols. Since WebRTC supports P2P connectivity the camera can send the video
directly to your browser. There is no reason for your video to be sent to a 3rd party server. Even when video is encrypted an attacker can make
assumptions from the metadata of the call.</p><p>Interoperability is another advantage for the IoT space. WebRTC is available in lots of different languages C#, C++, C, Go, Java, Python, Rust
and Typescript. This means you can use the language that works best for you. You also don&rsquo;t have to turn to proprietary protocols or formats
to be able to connect your two different clients.</p><h3 id=media-protocol-bridging>Media Protocol Bridging
<a class=anchor href=#media-protocol-bridging>#</a></h3><p>You have existing hardware and software that is producing video, but you can&rsquo;t upgrade it yet. Expecting users to download a proprietary
client to watch videos is frustrating. The answer is run a WebRTC bridge. The bridge translates between the two protocols so users can use the
browser with your legacy setup.</p><p>Many of the formats that developers bridge with use the protocols as WebRTC. SIP is commonly exposed via WebRTC and allows users to make phone calls
from their browser. RTSP is used in lots of legacy security cameras. They both use the same underlying protocols (RTP and SDP) so it is computationally cheap
to run. The bridge is just required to add or remove things that are WebRTC specific.</p><h3 id=data-protocol-bridging>Data Protocol Bridging
<a class=anchor href=#data-protocol-bridging>#</a></h3><h3 id=teleoperation>Teleoperation
<a class=anchor href=#teleoperation>#</a></h3><h3 id=distributed-cdn>Distributed CDN
<a class=anchor href=#distributed-cdn>#</a></h3><h2 id=webrtc-topologies>WebRTC Topologies
<a class=anchor href=#webrtc-topologies>#</a></h2><p>WebRTC is a protocol for connecting two agents, so how are developers connecting hundreds of people at once? There are a few different
ways you can do it and they all have pros and cons.</p><h3 id=peer-to-peer>Peer-To-Peer
<a class=anchor href=#peer-to-peer>#</a></h3><h4 id=one-to-one>One-To-One
<a class=anchor href=#one-to-one>#</a></h4><h4 id=p2p-mesh>P2P Mesh
<a class=anchor href=#p2p-mesh>#</a></h4><p>It is often desirable to connect more than two WebRTC peers together like in a group web call, or an online multiplayer game. There
are also many different ways to achieve WebRTC communications between more than two peers. One option is to create a Peer to Peer Mesh. There are two forms of Peer to Peer Meshes, a &ldquo;full mesh&rdquo; and a &ldquo;partial mesh&rdquo;. In a full mesh each peer makes a seperate WebRTC connection to every other peer that wants to communicate together. In a partial mesh, some peers are allocated more connections than others and are used to forward and/or route information between peers. In either case, each peer has to send copies of media to every other peer it is connected to making for high bandwidth cost for each peer when there are many users connected. Because of these bandwidth concerns, a Peer to Peer Mesh is best used for small groups connecting together.</p><h3 id=client-server>Client-Server
<a class=anchor href=#client-server>#</a></h3><p>The low-latency nature of WebRTC protocol is great for calls, and it&rsquo;s common to see conferences arranged in p2p mesh configuration
(for low latency), or peering through an SFU (Selective Forwarding Unit) to improve call quality. Since codec support varies by browser,
many conferencing servers allow browsers to broadcast using proprietary or non-free codecs like h264, and then re-encode to an open standard
like VP8 at the server level; when the SFU performs an encoding task beyond just forwarding packets, it is now called an MCU (Multi-point Conferencing Unit).
While SFU are notoriously fast and efficient and great for conferences, MCU can be very resource intensive! Some conferencing servers even
perform heavy tasks like compositing (combining together) A/V streams, customized for each caller, to minimize client bandwidth use by
sending only a single stream of all the other callers.</p><h4 id=sfu-selective-forwarding-unit>SFU (Selective Forwarding Unit)
<a class=anchor href=#sfu-selective-forwarding-unit>#</a></h4><h4 id=mcu-multi-point-conferencing-unit>MCU (Multi-point Conferencing Unit)
<a class=anchor href=#mcu-multi-point-conferencing-unit>#</a></h4></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div class=book-languages tabindex=0 aria-haspopup=true><ul><li class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
English</li></ul><ul class=book-languages-list><li class=active><a href=https://webrtcforthecurious.com/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
English</a></li><li><a href=https://webrtcforthecurious.com/tr/docs/08-applied-webrtc/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Turkish</a></li><li><a href=https://webrtcforthecurious.com/fa/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Persian</a></li><li><a href=https://webrtcforthecurious.com/zh/docs/08-applied-webrtc/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
简体中文</a></li></ul></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/0c2edeb4ec7ac6aa4971cdbadc89a226e686d7c4 title="Last modified by Will Forcey | April 2, 2021" target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>April 2, 2021</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content//docs/08-applied-webrtc.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#by-use-case>By Use Case</a><ul><li><a href=#conferencing>Conferencing</a></li><li><a href=#broadcasting>Broadcasting</a></li><li><a href=#remote-access>Remote Access</a></li><li><a href=#file-sharing-and-censorship-circumvention>File Sharing and Censorship Circumvention</a></li><li><a href=#iot>IoT</a></li><li><a href=#media-protocol-bridging>Media Protocol Bridging</a></li><li><a href=#data-protocol-bridging>Data Protocol Bridging</a></li><li><a href=#teleoperation>Teleoperation</a></li><li><a href=#distributed-cdn>Distributed CDN</a></li></ul></li><li><a href=#webrtc-topologies>WebRTC Topologies</a><ul><li><a href=#peer-to-peer>Peer-To-Peer</a></li><li><a href=#client-server>Client-Server</a></li></ul></li></ul></nav></aside></main></body></html>