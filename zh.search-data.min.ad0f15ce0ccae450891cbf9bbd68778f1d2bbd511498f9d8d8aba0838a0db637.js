'use strict';(function(){const indexCfg={encode:false,tokenize:function(str){return str.replace(/[\x00-\x7F]/g,'').split('');}};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/zh/docs/01-what-why-and-how/','title':"是什么，为什么，如何使用",'section':"Docs",'content':"WebRTC是什么？ #  WebRTC是Web实时通信（Real-Time Communication）的缩写，它既是API也是协议。WebRTC协议是两个WebRTC代理协商双向安全实时通信的一组规则。开发人员可以通过WebRTC API使用WebRTC协议。目前WebRTC API仅有JavaScript版本。\n可以用HTTP和fetch API来类比。WebRTC协议就是HTTP，而WebRTC API就是fetch API。\n除了JavaScript语言，WebRTC协议也可以在其他API/语言中使用。您还可以找到WebRTC的服务器和特定领域的工具。所有这些实现都使用WebRTC协议，因此它们可以彼此交互。\nWebRTC协议由IETF工作组在rtcweb中维护。WebRTC API的W3C文档在webrtc-pc。\n为什么我应该学习WebRTC？ #  下面这些就是WebRTC会给您的东西。这份清单并不详尽，只是您在学习旅途中可能会喜欢的一些东西。如果您还不了解其中一些术语，请不要担心，本书将陆续将这些概念教给您。\n 开放标准 多种实现 在浏览器中可用 强制加密 NAT遍历 重新利用现有技术 拥塞控制 亚秒级延迟  WebRTC协议是一组其他技术的集合体 #  这个主题需要整本书来解释。但是，首先，我们将其分为四个步骤。\n 信令（Signaling） 连接（Connecting） 保护（Securing） 通信（Communicating）  这四个步骤依次发生。上一个步骤必须100％成功，随后的步骤才能开始。\n关于WebRTC的一个特殊事实是，每个步骤实际上都是由许多其他协议组成的！为了制作WebRTC，我们将许多现有技术结合在一起。从这个意义上讲，WebRTC更加是自2000年代以来就已经存在的易于理解的技术的组合和配置。\n每个步骤都有专门的章节，但是首先从较高的层次上理解它们会有所帮助。由于它们彼此依赖，因此理解这些在进一步解释每个步骤的目的时会有所帮助。\n信令：peer如何在WebRTC中找到彼此 #  当WebRTC代理启动时，它不知道与谁通信以及他们将要通信的内容。信令解决了这个问题！信令用于引导呼叫，以便两个WebRTC代理可以开始通信。\n信令使用现有协议SDP。SDP是纯文本协议。每个SDP消息均由键/值对组成，并包含“media sections”列表。两个WebRTC代理交换的SDP所包含一些详细信息，如：\n 代理可访问的IP和端口（候选） 代理希望发送多少路音频和视频流 代理支持哪些音频和视频编解码器 连接时需要使用的值（uFrag/uPwd） 保护时使用的值（证书指纹）  注意，信令通常发生在“out-of-band”。也就是说，应用通常不使用WebRTC本身来交换信令消息。在连接的peer中，任何适合发送消息的架构均可被用于传递SDP信息，许多应用程序都使用其现有的基础结构（例如REST端点，WebSocket连接或身份验证代理）来解决适当客户端之间的SDP传递问题。\n使用STUN/TURN进行连接和NAT穿透 #  现在，两个WebRTC代理知道足够的详细信息以尝试相互连接。接下来，WebRTC将使用另一种成熟的技术，称为ICE。\nICE（交互式连接建立）是WebRTC之前的协议。ICE允许在两个代理之间建立连接。这些代理可以在同一网络上，也可以在世界的另一端。ICE是无需中央服务器即可建立直接连接的解决方案。\n这里真正的魔法是“ NAT穿透”和STUN/TURN服务器。这两个概念是与另一个子网中的ICE代理进行通信所需的全部。稍后我们将深入探讨这些主题。\nICE成功连接后，WebRTC继续建立加密的传输。此传输用于音频，视频和数据。\n使用DTLS和SRTP保护传输层 #  现在我们有了双向通信（通过ICE），我们需要建立安全的通信。这是通过WebRTC之前的两种协议完成的。第一个协议是DTLS（数据报传输层安全性），它只是基于UDP的TLS。TLS是用于保护通过HTTPS进行通信的加密协议。第二种协议是SRTP（安全实时传输协议）。\n首先，WebRTC通过在ICE建立的连接上进行DTLS握手来进行连接。与HTTPS不同，WebRTC不使用中央授权来颁发证书。相反，WebRTC只是判断通过DTLS交换的证书是否与通过信令共享的签名相符。然后，此DTLS连接可以被用于传输DataChannel消息。\n接下来，WebRTC使用RTP协议进行音频/视频的传输。我们使用SRTP来保护我们的RTP数据包。我们从协商的DTLS会话中提取密钥，用来初始化SRTP会话。在下一章中，我们讨论为什么媒体传输拥有其自己的协议。\n我们说完了！您现在可以进行安全的双向通信。如果您的WebRTC代理之间具有稳定的连接，上面这就是您可能需要解决的所有复杂问题。不幸的是，现实世界中存在着数据包丢失和带宽限制，下一章节将介绍我们如何处理它们。\n通过RTP和SCTP进行点对点通信 #  现在，我们有了两个具有安全的双向通信功能的WebRTC代理。让我们开始通信！跟前面一样，我们使用两个预先存在的协议：RTP（实时传输协议）和SCTP（流控制传输协议）。SRTP用于加密通过RTP交换的媒体，而SCTP用于发送使用DTLS加密的DataChannel消息。\nRTP很小，但是提供了实现实时流式传输所需的功能。重要的是，RTP为开发人员提供了灵活性，因此他们可以根据需要处理延迟，丢失和拥塞。我们将在媒体章节中对此进行进一步讨论。\n堆栈中的最终协议是SCTP。SCTP支持许多不同的消息传送选项。您可以选择不可靠的无序交付，以便获得实时系统所需的延迟。\nWebRTC是一系列协议的集合 #  WebRTC解决了许多问题。初看起来，这似乎是过度设计的。实际上，WebRTC非常克制。它并未认为它可以更好的解决所有问题。相反，它采纳了许多现有的单一目的技术，并将它们捆绑在一起。\n这使得我们可以独立的检查和学习每个部分，而不会毫无头绪。实际上，从另一个角度去看“ WebRTC代理”，它只是许多不同协议的协调器。\n mermaid.initialize({ \"flowchart\": { \"useMaxWidth\":true }, \"theme\": \"default\" } ) graph TB webrtc{WebRTC Agent} sctp{SCTP Agent} dtls{DTLS Agent} ice{ICE Agent} stun{STUN Protocol} turn{TURN Agent} srtp{SRTP Agent} sdp{SDP} rtp{RTP} rtcp{RTCP} webrtc -- ice webrtc -- dtls webrtc -- srtp webrtc -- sdp webrtc -- sctp ice -- turn ice -- stun srtp -- rtcp srtp -- rtp WebRTC（API）如何工作 #  本部分显示JavaScript API是如何跟协议相对应的。这不只是WebRTC API的一个粗略演示，更像是创建了一个思维模型，以此将所有部分联系在一起。如果您对各部分都不熟悉，那也不要紧。当您了解更多信息时，再回头看看这一部分，可能会很有趣！\nnew RTCPeerConnection #  RTCPeerConnection是最顶层的\u0026quot;WebRTC会话\u0026rdquo;。它包含上述所有协议。所有子系统都已就位，但是什么都还没有发生。\naddTrack #  addTrack创建一个新的RTP流。并将为这个流生成一个随机的SSRC（Synchronization Source/同步源）。然后，createOffer将生成会话描述符，这个流将被加入其中的媒体部分。每次调用addTrack都会创建一个新的SSRC和对应的媒体部分。\n在建立SRTP会话后，这些媒体数据包将被SRTP加密，然后立即通过ICE开始发送。\ncreateDataChannel #  如果没有SCTP关联存在，createDataChannel将创建一个新的SCTP流。默认情况下，SCTP是不启用的，只有在一方请求数据通道时才启动。\n在DTLS会话建立之后，SCTP关联将立即通过ICE发送数据包，并使用DTLS加密。\ncreateOffer #  createOffer生成本地状态的会话描述，以与远端Peer共享。\n调用createOffer的行为对于本地Peer没有任何改变。\nsetLocalDescription #  setLocalDescription提交所有请求的更改。 在此调用之前，addTrack，createDataChannel和类似调用都是临时的。 调用setLocalDescription时，使用由createOffer生成的值。\n通常，在此调用之后，您会将offer发送给远端Peer，他们将调用setRemoteDescription，将此offer设入。\nsetRemoteDescription #  收到远端Peer发来的offer之后，我们通过setRemoteDescription通知本地代理。这就是使用JavaScript API传递“信令”的方式。\n双方都调用过setRemoteDescription后，WebRTC代理现在拥有足够的信息来开始进行P2P通信！\naddIceCandidate #  addIceCandidate允许WebRTC代理随时添加更多远程ICE候选对象。该API将ICE候选对象发送到ICE子系统，并且对更大的WebRTC连接没有其他影响。\nontrack #  ontrack是从远端Peer收到RTP数据包时触发的回调。传入的RTP数据包应该已在传递给setRemoteDescription的会话描述中声明。\nWebRTC使用SSRC并查找关联的MediaStream和MediaStreamTrack，并使用填充的这些详细信息触发此回调。\noniceconnectionstatechange #  oniceconnectionstatechange是ICE代理的状态变化时触发的回调。当网络连接或断开时，您将得到此通知。\nonstatechange #  onstatechange是ICE代理和DTLS代理状态的组合。当ICE和DTLS都成功完成时，您将看到此通知。\n"});index.add({'id':1,'href':'/zh/docs/02-signaling/','title':"信令",'section':"Docs",'content':"什么是WebRTC信令？ #  当一个WebRTC代理被创建时，它对其他peer一无所知。它不知道它将与谁联系，也不知道它们将发送些什么！ 信令是使呼叫成为可能的初始引导程序。交换信令消息后，WebRTC代理才可以直接相互通信。\n信令消息只是文本。WebRTC代理并不关心它们的传递方式。信令通常使用Websockets分享，但这不是必需的。\nWebRTC信令如何工作？ #  WebRTC使用到一种现有的协议，称为会话描述协议（Session Description Protocol，简称SDP）。两个WebRTC代理会将建立连接所需的所有状态通过此协议来分享。该协议本身亦易于阅读和理解。 但要理解WebRTC填充于协议中的所有值，将有一定复杂性。\n该协议不特定于WebRTC。我们将首先学习会话描述协议，这里甚至不用谈论WebRTC。WebRTC实际上仅利用了协议的子集，因此我们将仅介绍我们所需的内容。 理解协议后，我们将继续结合WebRTC来说明其在实际中的应用方法。\n什么是 会话描述协议（SDP）？ #  会话描述协议定义于 RFC 4566 中。它是一个key/value协议，每一行是一个值。看起来类似于INI文件。 一个会话描述包含零个或多个媒体描述。对此模型，可以理解为会话描述包含了一个媒体描述的数组。\n一个媒体描述通常映射到单个媒体流。因此，如果您想描述一个包含三个视频流和两个音轨的呼叫，需要五个媒体描述。\n如何阅读SDP信息 #  会话描述中的每一行都将以一个单字符开始，这是您的key。单字符后面将跟随一个等号。等号后的所有内容都是value。value结束的地方将有一个换行符。\n会话描述协议定义了所有有效的key。对于协议中定义的key，您只能使用字母。这些key都有重要的意义，稍后将对此进行解释。\n作为参考，下面是一个会话描述的部分内容。\na=my-sdp-value a=second-value 这里有两行。每行的key都是a。第一行的value为my-sdp-value，第二行的value为second-value。\nWebRTC仅使用了部分SDP的key #  WebRTC并未使用会话描述协议定义的所有key。您当前只需要理解下面的7个key。\n v - Version，版本，版本，应等于0 o - Origin，源，包含一个唯一ID，用于重新协商 s - Session Name，会话名称，应等于- t - Timing，时间，应等于0 0 m - Media Description，媒体描述，下面有详细说明 a - Attribute，属性，一个自由文本字段，这是WebRTC中最常见的行 c - Connection Data，连接数据，应等于IN IP4 0.0.0.0  会话描述中的媒体描述 #  一个会话描述中，可以包含无限数量的媒体描述。\n一个媒体描述定义中，包含一个格式列表。这些格式映射到RTP有效负载类型。然后，实际的编解码器由媒体描述中的rtpmap属性定义。 RTP和RTP有效负载类型的重要性将在后面的 媒体 一章中讨论。每个媒体描述可以包含无限数量的属性。\n作为参考例子，下面是一个会话描述的部分内容。\nv=0 m=audio 4000 RTP/AVP 111 a=rtpmap:111 OPUS/48000/2 m=video 4000 RTP/AVP 96 a=rtpmap:96 VP8/90000 a=my-sdp-value 这里面有两个媒体描述，第一个是音频，格式为fmt 111，另一个是视频，格式为fmt 96。第一个媒体描述只有一个属性。该属性将有效载荷类型111映射到Opus编解码器。 第二个媒体描述具有两个属性。第一个属性将有效负载类型96映射到VP8编解码器，第二个属性只是my-sdp-value。\n译注：参照前面key的定义，第1行的v=0表示版本为0，第2/3行是第一个媒体描述，第4/5/6行是第二个媒体描述  完整示例 #  以下内容将我们讨论过的所有概念整合在一起。这些是WebRTC所使用的会话描述协议的所有特性。 如果您可以读懂这个例子，那么您可以读懂任何WebRTC会话描述！\nv=0 o=- 0 0 IN IP4 127.0.0.1 s=- c=IN IP4 127.0.0.1 t=0 0 m=audio 4000 RTP/AVP 111 a=rtpmap:111 OPUS/48000/2 m=video 4002 RTP/AVP 96 a=rtpmap:96 VP8/90000  v, o, s, c, t 虽然被定义，但他们不对WebRTC会话产生影响。 这里有两个媒体描述。一个是audio即音频类型，一个是video即视频类型。 每个媒体描述都有一个属性。这个属性配置了RTP管道的详细信息，这部分将在“媒体通信”章节详细讨论  会话描述协议 和WebRTC如何协同工作 #  下一块拼图是理解WebRTC如何使用会话描述协议。\n什么是Offer和Answer？ #  WebRTC使用Offer/Answer模型。这指的是，一个WebRTC代理发出\u0026rsquo;Offer\u0026rsquo;以开始呼叫，如果另一个WebRTC代理愿意接受\u0026rsquo;Offer\u0026rsquo;的内容，它会发出\u0026rsquo;Answer\u0026rsquo;。\n这使得应答者有机会拒绝某些编解码器和媒体描述，也是两个peer互相理解他们愿意交换什么的方式。\n用于发送和接收的收发器（Transceivers） #  收发器是WebRTC中特有的概念，您将在API中看到它。它的作用是将“媒体描述”暴露给JavaScript API。每个媒体描述都将成为一个收发器。每次创建收发器时，都会将新的媒体描述添加到本地会话描述中。\nWebRTC中的每个媒体描述都包含一个direction属性。这样，WebRTC代理可以声明“我将向您发送此编解码器，但我不打算接受任何返回的内容”。direction属性有四个有效值：\n send recv sendrecv inactive  WebRTC用到的SDP值 #  这个列表包含了您将在WebRTC代理的会话描述中看到的一些常见属性。这些值控制着我们尚未讨论到的子系统。\ngroup:BUNDLE #  BUNDLE是一种在单个连接上传输多种类型流量的行为。一些WebRTC实现对每个媒体流会使用专用的连接。但BUNDLE方式应该是首选。\nfingerprint:sha-256 #  该属性是peer用于DTLS证书的哈希值。DTLS握手完成后，您可以将其与实际证书进行比较，以确认您正在与预期的对象进行通信。\n译注：下面是RFC 4572中的一个例子\na=fingerprint:SHA-1 \\ 4A:AD:B9:B1:3F:82:18:3B:54:02:12:DF:3E:5D:49:6B:19:E5:7C:AB   setup: #  该属性控制了DTLS代理的行为。在ICE连接后，该属性将确定DTLS代理是作为客户端还是服务器来运行。有以下几个可能的值：\n setup:active - 作为DTLS客户端运行 setup:passive - 作为DTLS服务器运行 setup:actpass - 要求其他WebRTC代理选择  ice-ufrag #  该属性是ICE代理的用户片段值。用于ICE流量的身份验证。\nice-pwd #  该属性是ICE代理的密码。用于ICE流量的身份验证。\nrtpmap #  该属性用于将特定的编解码器映射到RTP有效负载类型。有效负载类型不是静态的，因此呼叫发起者每次呼叫时都需要确定每个编解码器的有效负载类型。\nfmtp #  该属性为一种有效负载类型定义附加的值。要传递特定的视频配置文件或编码器设置时，这很有用。\ncandidate #  该属性是来自ICE代理的ICE候选。这是一个可能被WebRTC代理使用的地址。这些将在下一章中详细说明。\nssrc #  一个同步源（SSRC）定义了一个单独的媒体流。\nlabel是此媒体流的ID。mslabel是容器的ID，该容器中可以有多个流。\nWebRTC会话描述示例 #  下面是一个WebRTC客户端生成的一套完整会话描述。\nv=0 o=- 3546004397921447048 1596742744 IN IP4 0.0.0.0 s=- t=0 0 a=fingerprint:sha-256 0F:74:31:25:CB:A2:13:EC:28:6F:6D:2C:61:FF:5D:C2:BC:B9:DB:3D:98:14:8D:1A:BB:EA:33:0C:A4:60:A8:8E a=group:BUNDLE 0 1 m=audio 9 UDP/TLS/RTP/SAVPF 111 c=IN IP4 0.0.0.0 a=setup:active a=mid:0 a=ice-ufrag:CsxzEWmoKpJyscFj a=ice-pwd:mktpbhgREmjEwUFSIJyPINPUhgDqJlSd a=rtcp-mux a=rtcp-rsize a=rtpmap:111 opus/48000/2 a=fmtp:111 minptime=10;useinbandfec=1 a=ssrc:350842737 cname:yvKPspsHcYcwGFTw a=ssrc:350842737 msid:yvKPspsHcYcwGFTw DfQnKjQQuwceLFdV a=ssrc:350842737 mslabel:yvKPspsHcYcwGFTw a=ssrc:350842737 label:DfQnKjQQuwceLFdV a=msid:yvKPspsHcYcwGFTw DfQnKjQQuwceLFdV a=sendrecv a=candidate:foundation 1 udp 2130706431 192.168.1.1 53165 typ host generation 0 a=candidate:foundation 2 udp 2130706431 192.168.1.1 53165 typ host generation 0 a=candidate:foundation 1 udp 1694498815 1.2.3.4 57336 typ srflx raddr 0.0.0.0 rport 57336 generation 0 a=candidate:foundation 2 udp 1694498815 1.2.3.4 57336 typ srflx raddr 0.0.0.0 rport 57336 generation 0 a=end-of-candidates m=video 9 UDP/TLS/RTP/SAVPF 96 c=IN IP4 0.0.0.0 a=setup:active a=mid:1 a=ice-ufrag:CsxzEWmoKpJyscFj a=ice-pwd:mktpbhgREmjEwUFSIJyPINPUhgDqJlSd a=rtcp-mux a=rtcp-rsize a=rtpmap:96 VP8/90000 a=ssrc:2180035812 cname:XHbOTNRFnLtesHwJ a=ssrc:2180035812 msid:XHbOTNRFnLtesHwJ JgtwEhBWNEiOnhuW a=ssrc:2180035812 mslabel:XHbOTNRFnLtesHwJ a=ssrc:2180035812 label:JgtwEhBWNEiOnhuW a=msid:XHbOTNRFnLtesHwJ JgtwEhBWNEiOnhuW a=sendrecv a=candidate:foundation 1 udp 2130706431 192.168.1.1 53165 typ host generation 0 a=candidate:foundation 2 udp 2130706431 192.168.1.1 53165 typ host generation 0 a=candidate:foundation 1 udp 1694498815 1.2.3.4 57336 typ srflx raddr 0.0.0.0 rport 57336 generation 0 a=candidate:foundation 2 udp 1694498815 1.2.3.4 57336 typ srflx raddr 0.0.0.0 rport 57336 generation 0 a=end-of-candidates 从这个会话描述中，我们可以知道以下内容：\n 我们有两个媒体描述，一个是音频，一个是视频 这两个媒体描述都是 sendrecv 收发器。 我们将得到两个流，也可以发送两个流回去。 我们有候选ICE代理和身份验证的详细信息，因此我们可以尝试连接 我们有一个证书指纹，因此我们可以进行安全的呼叫  译注：对照以上4点\n 两个媒体描述即是两个m=段 两个m段中都有a=sendrecv，即是说可以收也可以发 候选ICE代理对应a=candidate:foundation到a=end-of-candidates之间的部分，身份验证信息参考前面的ice-ufrag和ice-pwd等 指的是fingerprint:sha-256属性   进一步的话题 #  在本书的后面的版本中，还将讨论以下主题。如果您还有其他问题，请提交Pull Request！\n 重新协商（Renegotiation） 同步广播（Simulcast）  "});index.add({'id':2,'href':'/zh/docs/03-connecting/','title':"连接",'section':"Docs",'content':"为什么WebRTC需要专用的子系统进行连接？ #  目前，大多数部署的应用程序都通过客户端/服务器方式进行连接。对于客户端/服务器连接，它要求服务器具有稳定且公开可用的传输地址。客户端与服务器联系，然后服务器做出响应。\nWebRTC不使用客户端/服务器，它建立点对点（P2P）连接。 在P2P连接中，创建连接的任务被平均分配给两个对等方。这是因为无法猜测WebRTC中的传输地址（IP和端口），而且，在会话过程中，传输地址甚至可能会变更。WebRTC将收集所有可能收集的信息，并将尽力实现两个WebRTC代理之间的双向通信。\n听起来简单，建立点对点连接实际上可能会非常困难。这些代理可能位于没有直接连接的不同网络中。即使在两个代理可以直接连接的情况下，您可能还会遇到其他问题。比如在某些情况下，两个客户端使用不同的网络协议（UDP \u0026lt;-\u0026gt; TCP）或使用不同的IP版本（IPv4 \u0026lt;-\u0026gt; IPv6）。\n尽管在建立点对点连接方面存在一些困难，在WebRTC提供的下面这些属性的帮助下，您仍然可以获得相对于传统客户端/服务器技术的一些优势。\n降低带宽成本 #  由于媒体通信直接发生在Peer之间，因此您无需为传输它而付费（无需经过第三方服务器并为此付费）。\n更低延迟 #  直接通信时速度更快！当用户必须通过您的服务器运行所有内容时，这会使事情变慢。\n安全的端到端通信 #  直接通信更安全。由于用户数据根本没有通过服务器，因此用户不需要考虑服务端会不会解密。\n它是如何工作的？ #  上面描述的连接过程是通过Interactive Connectivity Establishment（交互式连接建立/ICE） 实现的。这是另一个在WebRTC之前就已经出现的协议。\nICE是一种用来寻找两个ICE代理之间通信的最佳方式的协议。每个ICE代理都会发布如何访问自己的方式，这些路径被称为候选地址（candidates）。候选地址本质上是一个传输地址，ICE代理认为这个传输地址可能可以被对端访问到。接下来ICE将确定候选地址的最佳搭配。\n本章稍后将详细介绍实际的ICE过程。要了解ICE为什么存在，最好先了解我们要面临的网络特性。\n现实世界的网络限制 #  ICE就是克服现实世界网络限制的方法。在我们开始讨论ICE如何解决问题之前，先讨论一下有哪些实际问题。\n不在同一个网络中 #  在大多数情况下，两个WebRTC代理不在同一个网络中。典型的呼叫通常是在没有直接连接的不同网络中的两个WebRTC代理之间进行的。\n下面是通过公共互联网连接的两个不同网络的示意图。在每个网络中，您拥有两个主机。\n mermaid.initialize({ \"flowchart\": { \"useMaxWidth\":true }, \"theme\": \"default\" } ) graph TB subgraph netb [\"Network B (IP Address 5.0.0.2)\"] b3[\"Agent 3 (IP 192.168.0.1)\"] b4[\"Agent 4 (IP 192.168.0.2)\"] routerb[\"Router B\"] end subgraph neta [\"Network A (IP Address 5.0.0.1)\"] routera[\"Router A\"] a1[\"Agent 1 (IP 192.168.0.1)\"] a2[\"Agent 2 (IP 192.168.0.2)\"] end pub{Public Internet} routera--pub routerb--pub 对于同一网络中的主机来说，互相连接非常容易。例如在192.168.0.1 -\u0026gt; 192.168.0.2之间通讯就很容易！这两个主机无需任何外部帮助即可相互连接。\n但是，使用Router B的主机无法直接访问Router A背后的任何主机。您如何区分Router A后面的191.168.0.1主机和Router B后面相同IP的主机之间的区别呢？它们都使用内网IP！使用Router B的主机可以将数据直接发送到Router A，但是请求在那里就结束了。Router A怎么知道它应该将消息转发给哪台主机呢？\n协议限制 #  有些网络不允许UDP通信，或者也有可能不允许TCP。有些网络的MTU（Maximum Transmission Unit/最大传输单元）可能非常低。网络管理员可以更改许多变量，这些修改可能会使通信变得困难。\n防火墙/IDS规则 #  另一个问题是深度数据包检查和其他智能过滤方式。某些网络管理员将运行一些软件，这些软件会试图处理每个数据包。很多时候，这些软件无法识别WebRTC的数据包，由于它们不知道如何处理，它们可能会阻拦这些数据包，例如，它们可能将WebRTC数据包视为不在端口白名单上的可疑UDP数据包。\nNAT映射 #  NAT（网络地址转换）映射是使得WebRTC连接成为可能的魔法。WebRTC就是使用NAT让处于完全不同的子网中的两个peer进行通信，从而解决了上述\u0026quot;不在同一网络中\u0026quot;的问题，这同时也带来了新的挑战。首先，让我们解释一下NAT映射是如何工作的。\nNAT映射不使用中继，代理或服务器。跟上一个例子一样，我们有Agent 1和Agent 2，它们位于不同的网络中。然而，流量穿透了路由器。看起来就像这样：\ngraph TB subgraph netb [\"Network B (IP Address 5.0.0.2)\"] b2[\"Agent 2 (IP 192.168.0.1)\"] routerb[\"Router B\"] end subgraph neta [\"Network A (IP Address 5.0.0.1)\"] routera[\"Router A\"] a1[\"Agent 1 (IP 192.168.0.1)\"] end pub{Public Internet} a1-.-routera; routera-.-pub; pub-.-routerb; routerb-.-b2; 想要这样通信的话，您需要创建一个NAT映射。Agent 1使用端口7000与Agent 2建立WebRTC连接。这将创建一个192.168.0.1:7000到5.0.0.1:7000的绑定。然后，Agent 2将数据包发送到5.0.0.1:7000时，数据包会被转发给Agent 1。在这个例子中，创建一个NAT映射，就像是在路由器中做了一次自动化的端口转发。\nNAT映射的缺点是：映射的形式不止一种（例如静态端口转发），并且映射的实现方式在不同的网络中也是不一样的。ISP和硬件制造商可能会以不同的方式来实现NAT映射。在某些情况下，网络管理员甚至可能禁用它。\n好消息是，NAT映射的所有行为都是可以理解和观察到的，因此ICE代理能够确认其创建了NAT映射，并确认该映射的属性。\n描述这些行为的文档是 RFC 4787。\n创建映射 #  创建映射是最简单的部分。当您将数据包发送到网络外部的地址时，一个映射就被创建出来了！NAT映射只是由NAT分配的一个临时的公共IP/端口。出站的消息将被重写，使得其源地址变为新创建的映射地址。如果有消息被成功发到映射地址，消息会被自动路由返回给NAT网络中创建这个映射地址的主机。\n说到映射相关的细节，这就开始变得复杂了。\n映射创建的行为 #  映射创建分为三类：\n端点无关的映射 #  这种创建方式为NAT网络中的所有发送者只创建一个映射。如果您将两个数据包发送到两个不同的远程地址，这个NAT映射将被重用。两个远程主机将看到相同的源IP/端口。如果远程主机响应，它将被发送回相同的本地侦听器。\n这是最好的情况。要使得呼叫能够建立起来，至少一侧必须是这种类型。\n地址相关的映射 #  每次将数据包发送到新地址时，都会创建一个新的映射。如果您将两个数据包发送到不同的主机，则会创建两个映射。如果将两个数据包发送到同一远程主机，但目标端口不同，则不会创建新的映射。\n地址和端口相关的映射 #  如果远程IP或端口不同，则会创建一个新的映射。如果将两个数据包发送到同一远程主机，但目标端口不同，则将创建一个新的映射。\n映射过滤行为 #  映射过滤是关于允许谁使用映射的规则。它们分为三个类似的类别：\n端点无关的过滤 #  任何人都可以使用该映射。您可以与其他多个peer共享该映射，他们都可以向该映射发送流量。\n地址相关的过滤 #  只有为其创建映射的主机才能使用该映射。如果您将数据包发送到主机A，则它可以根据需要返回任意数量的数据包。如果主机B尝试将数据包发送到该映射，将被忽略。\n地址和端口相关的过滤 #  仅有创建映射的主机和端口可以使用该映射。如果您将数据包发送到主机A:5000，则它可以根据需要返回任意数量的数据包。如果主机A：5001尝试将数据包发送到该映射，将被忽略。\n映射的刷新 #  通常的建议是，如果5分钟未使用映射，则应将其销毁。但这完全取决于ISP或硬件制造商。\n译注：换个说法，NAT映射的创建即是NAT网络中的主机发送数据时，路由器的处理方式；而过滤即是接收数据时，路由器的处理方式。映射的刷新即是路由器释放映射的处理方式。不同网络情况不同，因此某些特定的搭配会导致两个网络间无法建立P2P连接。在穿透相关的技术中，将不同的情况称为不同的锥形。  STUN #  STUN（NAT会话传输实用程序）是一种用来配合NAT使用的协议。这是WebRTC（和ICE！）之前的另一项技术。它由RFC 5389定义，该文件还定义了STUN数据包结构。STUN协议也在ICE/TURN中被使用。\nSTUN很有用，因为它允许以编程方式创建NAT映射。在STUN之前，我们能够创建NAT映射，但是我们不知道映射的IP/端口是什么！STUN不仅使您能够创建映射，还可以获取映射的详细信息，用来与他人共享，这样他们便可以通过您创建的映射向您传送数据。\n让我们从对STUN的基本描述开始。稍后，我们再将话题扩展到TURN和ICE的用法。现在，我们只打算描述请求/响应流程来创建映射。然后，我们将讨论如何获取该映射的详细信息以便与他人共享。当您在ICE URLs中有一个用于WebRTC PeerConnection的stun:服务器时，此过程就会发生。简而言之，STUN向NAT外部的STUN服务器发送请求，服务器返回其在请求中观察到的内容，STUN根据这些内容来帮助NAT后面的端点找出已创建的映射。\n协议结构 #  每个STUN数据包都具有以下结构：\n 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |0 0| STUN Message Type | Message Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Magic Cookie | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | | | Transaction ID (96 bits) | | | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Data | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ STUN 消息类型 #  每个STUN数据包都有一个类型。目前，我们仅关心以下几种：\n Binding Request - 0x0001 Binding Response - 0x0101  为了创建一个NAT映射，我们发出一个Binding Request。然后服务器回应一个Binding Response。\n消息长度 #  这就是Data段的长度。这一段中包含由消息类型所定义的任意数据。\nMagic Cookie #  指的是固定值0x2112A442，以网络字节顺序发送。这个值有助于将STUN流量与其他协议区分开。\n交互（Transaction）ID #  一个96-bit的标识符，用于唯一标识一个请求/响应对。这可以帮助您配对请求和响应。\n数据 #  数据将包含一个STUN属性的列表。一个STUN属性具有以下结构。\n0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Type | Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Value (variable) .... +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ STUN Binding Request不使用任何属性。这意味着一个STUN Binding Request仅包含header。\nSTUN Binding Response使用一个XOR-MAPPED-ADDRESS (0x0020)。此属性包含一个IP/端口对。这正是所创建的NAT映射的IP/端口对！\n创建NAT映射 #  使用STUN创建NAT映射只需要发送一个请求！您向STUN服务器发送一个STUN Binding Request。然后，STUN服务器回应一个STUN Binding Response。 该STUN Binding Response将包含映射地址。映射地址是STUN服务器看到您的方式，也是您的NAT映射。 如果您希望某人向您发送数据包，那么您应该共享该映射地址。\n人们还会将映射地址称为公网IP或Server Reflexive Candidate。\n确定NAT类型 #  不幸的是，映射地址可能并非在所有情况下都可用。如果是地址相关的映射，则只有STUN服务器才能将流量发送回给您。如果您共享它，那么另一个peer尝试向该地址发送的消息将被丢弃。这使得该peer无法与别的peer交流。如果STUN服务器还可以为您将数据包转发给对端peer，您可能会发现地址相关的映射问题实际上是可以解决的！这也就是下面将要说到的TURN解决方案。\nRFC 5780定义了一种方法，可以运行一个测试来确定您的NAT类型。 这很有用，因为您可能会提前知道是否可以进行直接连接。\nTURN #  在无法建立直接连接的情况下，RFC 5766中定义了TURN（使用中继穿透NAT）。当您的两个peer的NAT类型不兼容，或者双方使用不同协议时，就需要使用TURN！TURN也可以被用于保护隐私的目的。如果通过TURN运行所有通讯，客户的真实地址在对端是被隐藏的。\nTURN使用专用服务器。该服务器充当客户端的代理。客户端连接到TURN服务器并创建一个对应的Allocation。通过创建该Allocation，客户端将获得一个临时IP/端口/协议三元组，其他peer可以使用该IP/端口/协议将数据发送给该客户端。这个新的监听地址被称为中继传输地址。您可将其视为转发地址并分享给他人，以便其他人可以通过TURN向您发送流量！对于每个将获得该中继传输地址的peer，您必须为其创建一个新的Permission，以允许它与您进行通信。\n当您通过TURN发送出站流量时，它会通过中继传输地址发送。当远程peer获得该出站流量时，他们会看到数据来自TURN服务器。\nTURN生命周期 #  下面就是一个客户端创建TURN allocation时必须做的所有事情。对于其他peer而言，与使用TURN服务器的客户端进行通信和其他客户端没有任何区别，先获得IP/端口，然后像跟其他任何主机一样通信。\nAllocations #  Allocations是TURN的核心。本质上，一个allocation就是一个TURN会话。要创建一个TURN allocation，您需要与TURN Server Transport Address（服务器传输地址，通常在3478端口）进行通信。\n创建allocation时，您需要提供/确定以下内容\n 用户名/密码 - 创建TURN allocation时需要身份验证 Allocation传输方式 - 中继传输地址可以是UDP或TCP方式 连续端口 - 您可以为多个allocation请求顺序排列的一系列端口，这点与WebRTC无关  如果请求成功，您将在TURN服务器上获得响应，在响应的数据部分，包含以下的STUN属性。\n XOR-MAPPED-ADDRESS - TURN Client的Mapped Address。当有人将数据发送到中继传输地址时，数据将被转发到该地址。 RELAYED-ADDRESS - 这是您提供给其他客户端的地址。如果有人将数据包发送到该地址，则会将其转发到TURN客户端。 LIFETIME - Allocation被销毁的时间。您可以通过发送Refresh请求来延长这一时间。  译注：上面两个地址很拗口，但实际上理解起来并不复杂。Mapped Address是Turn Client的实际地址，也就是Turn Server收到数据包时的目标地址。而Relayed Address时Turn Client的名义地址，也就是其他WebRTC Agent要发送数据给这个Turn Client时，所使用的地址。  权限 #  在您为远程主机创建权限之前，远程主机是无法通过您的中继传输地址发送数据的。所谓创建权限，即是告知TURN服务器一个\u0026quot;可以用来发送入站流量\u0026quot;的IP/端口。\n远程主机需要先为您提供TURN服务器上使用的IP/端口。这意味着它应该先向TURN服务器发送一个STUN绑定请求。 有时会发生这样一个常见的错误情况，即是远程主机发送STUN绑定请求到另外一台服务器，然后再要求TURN服务器为此IP创建权限。\n对于上面那种错误情况，假设您要为一个使用地址相关的映射的NAT网络的主机创建权限，如果您从其他TURN服务器生成映射地址，则所有入站流量都将被丢弃。因为每次他们与其他主机通信时，它都会生成一个新的映射。如果未被刷新，权限将在5分钟后过期。\n译注：对于这个常见的错误情况，实际指的是被连接的主机从TURN服务器以外的STUN/TURN服务器获取本机IP，再告知发起连接的主机这样的情况。当被连接的主机使用地址相关的映射类型的NAT时，它获取的IP在当前的TURN服务器上是无效的。  SendIndication/ChannelData #  这是TURN客户端将消息发送到远端peer时所使用的两个消息。\nSendIndication是一个自包含的消息。它包含您希望发送的数据，以及您希望发送的目标。如果您要向远端peer发送大量消息的话，这种方式很昂贵。因为如果要发送1,000条消息，目标IP地址就被重复了1,000次！\nChannelData允许您发送数据，但不需要重复IP地址。您需要先创建一个具有IP/端口的通道（Channel）。然后使用ChannelId发送，IP/端口将在服务器端被填充进去。如果您要发送大量消息，这是更好的选择。\n刷新 #  Allocations将自动销毁。要避免其过早销毁，TURN客户端必须在创建allocation时指定的LIFETIME到来之前，及时刷新它们。\nTURN 使用方法 #  TURN有两种用法。通常情况下，一个peer会作为\u0026rsquo;TURN客户端\u0026rsquo;连接，而另一方则直接进行通信。在某些情况下，您可能在两侧都需要使用TURN服务。举例来说，当两个客户端都位于在禁用UDP的网络中时，只能通过TCP连接到各自的TURN服务器来建立连接。\n下面这些图有助于说明TURN的用法。\n单个 TURN Allocation 通信 #  graph TB subgraph turn [\"TURN Allocation\"] serverport[\"Server Transport Address\"] relayport[\"Relayed Transport Address\" ] end turnclient{TURN Client} peer{UDP Client} turnclient--|\"ChannelData (To UDP Client)\"|serverport serverport--|\"ChannelData (From UDP Client)\"|turnclient peer--|\"Raw Network Traffic (To TURN Client)\"|relayport relayport--|\"Raw Network Traffic (To UDP Client)\"|peer 双重 TURN Allocation 通信 #  graph TB subgraph turna[\"TURN Allocation A\"] serverportA[\"Server Transport Address\"] relayportA[\"Relayed Transport Address\" ] end subgraph turnb[\"TURN Allocation B\"] serverportB[\"Server Transport Address\"] relayportB[\"Relayed Transport Address\" ] end turnclientA{TURN Client A} turnclientB{TURN Client B} turnclientA--|\"ChannelData\"|serverportA serverportA--|\"ChannelData\"|turnclientA turnclientB--|\"ChannelData\"|serverportB serverportB--|\"ChannelData\"|turnclientB relayportA--|\"Raw Network Traffic\"|relayportB relayportB--|\"Raw Network Traffic\"|relayportA 译注：单个TURN Allocation的情况，指的是一个TURN Client和另一个可访问的UDP Client的通信。双重TURN Allocation的情况，指的是两个TURN Client之间通信。  ICE #  ICE（交互式连接建立）是WebRTC连接两个代理的方式。这也是WebRTC之前的一项技术，在RFC 8445中定义！ICE是用于建立连接的协议。它会确定两个peer之间所有可能的路由，然后确保您保持连接状态。\n这些路由被称为Candidate Pair（候选地址对），也就是本地地址和远程地址的配对。这就是STUN和TURN在ICE中发挥作用的地方。这些地址可以是您的本地IP地址，NAT映射或中继传输地址。通信双方需要收集它们要使用的所有地址，交换这些地址，然后尝试连接！\n两个ICE代理使用ICE ping数据包（正式名称为连通性检查）进行通信。一旦建立连接后，他们就可以发送任何信息。感觉就像使用普通socket一样。连通性检查使用STUN协议。\n创建ICE代理 #  ICE代理要么处于控制中，要么处于受控中。控制中的代理是决定选择候选对的代理。通常来说，发送offer的peer是控制中的一方。\n每一方都必须有一个用户片段和一个密码。必须先交换这两个值，才能进行连接检查。用户片段以纯文本形式发送，用于多个ICE会话的解复用（demux）。 密码用于生成MESSAGE-INTEGRITY属性。在每个STUN数据包的末尾，都有这个属性，该属性是使用密码作为密钥的整个数据包的哈希值。这用于验证数据包并确保它未被篡改。\n对于WebRTC，所有这些值都通过上一章中所述的会话描述进行分发。\n候选地址收集 #  现在，我们需要收集所有可能联通的地址。这些地址被称为候选地址。这些候选地址也通过会话描述来分发。\n主机 #  主机候选地址直接在本地接口上侦听。可以是UDP或TCP方式。\nmDNS #  mDNS候选地址类似于主机候选地址，但是其IP地址是隐藏的。您不必给对方提供您的IP地址，只需要给他们提供一个UUID作为主机名。然后设置一个多播监听器，并在有人请求您发布的UUID时进行响应。\n如果您与代理位于同一网络中，则可以通过多播找到彼此。如果不在同一网络中，则将无法连接（除非网络管理员明确配置网络以允许多播数据包通过）。\n这对于保护隐私很有用。以前，用户可以通过WebRTC使用主机候选地址（甚至无需尝试与您连接）来找出您的本地IP地址。而使用mDNS候选地址的话，他们只能获得随机的UUID。\n服务器自反（Server Reflextive） #  服务器自反候选地址是通过对STUN服务器执行STUN绑定请求时生成的。\n当您收到STUN绑定响应时，XOR-MAPPED-ADDRESS就是您的服务器自反候选地址。\nPeer自反 #  Peer自反候选地址是指，当您从您不知道的地址收到入站请求时，由于ICE是经过身份验证的协议，因此您知道这些传输是合法的，这只是意味着远端Peer是通过它也不知道的地址与您通信。\n这通常会发生在这样的情况下，当主机候选地址与服务器自反候选地址进行通信时，由于您是在子网外部进行通信，因此创建了一个新的NAT映射。还记得我们说过的连通性检查实际上是STUN数据包吗？STUN响应的格式自然允许peer报告Peer自反地址。\n中继 #  中继候选地址是通过使用TURN服务器生成的。\n在与TURN服务器进行初始握手之后，您将获得RELAYED-ADDRESS，这就是您的中继候选地址。\n连通性检查 #  现在我们知道了远程代理的用户片段，密码和候选地址。我们可以尝试连接了！ 候选地址可以相互配对。因此，如果每边有3个候选地址，那么现在就有9个候选地址对。\n看起来像这样 graph LR subgraph agentA[\"ICE Agent A\"] hostA{Host Candidate} serverreflexiveA{Server Reflexive Candidate} relayA{Relay Candidate} end style hostA fill:#ECECFF,stroke:red style serverreflexiveA fill:#ECECFF,stroke:green style relayA fill:#ECECFF,stroke:blue subgraph agentB[\"ICE Agent B\"] hostB{Host Candidate} serverreflexiveB{Server Reflexive Candidate} relayB{Relay Candidate} end hostA --- hostB hostA --- serverreflexiveB hostA --- relayB linkStyle 0,1,2 stroke-width:2px,fill:none,stroke:red; serverreflexiveA --- hostB serverreflexiveA --- serverreflexiveB serverreflexiveA --- relayB linkStyle 3,4,5 stroke-width:2px,fill:none,stroke:green; relayA --- hostB relayA --- serverreflexiveB relayA --- relayB linkStyle 6,7,8 stroke-width:2px,fill:none,stroke:blue; 候选地址选择 #  控制中的代理和受控中的代理都开始在每个候选地址对上发送流量数据。这样是必须的，因为如果一个代理位于一个地址相关映射的网络中，这样会创建Peer自反候选地址。\n每个收到流量数据的候选地址对，会被提升为有效候选地址对。接下来，控制中的代理将指定一个有效候选地址对。这就是提名候选地址对。然后，控制中的代理和受控中的代理再尝试进行一轮双向通信。如果成功，则提名候选地址对将成为选定的候选地址对！它将被用于后面的会话中。\n重新启动 #  如果选定的候选地址对由于任何原因停止工作（如：NAT映射到期，TURN服务器崩溃等），则ICE代理将进入失败状态。此时可以重新启动两个代理，然后重新完整执行整个过程。\n"});index.add({'id':3,'href':'/zh/docs/04-securing/','title':"安全性",'section':"Docs",'content':"WebRTC具有哪些安全性保障？ #  每个WebRTC连接都经过身份验证和加密。您可以确信第三方看不到您发送的内容，也无法插入虚假消息。您还可以确保与您进行通信的WebRTC代理正是生成会话描述的代理。\n没有人能够篡改消息这一点非常重要。如果第三方在传输中读取了会话描述，这不会产生什么影响。然而，WebRTC无法防止会话描述被修改。攻击者可以通过更改ICE候选地址和证书指纹来对您进行中间人攻击（man-in-the-middle）。\n译注：这里指的是，P2P连接建立之后，双方之间的通信安全是有保障的。但在连接建立的过程中，攻击者可以通过man-in-the-middle方式伪装中间人同时与通信双方建立连接并通信。  它是如何做到的？ #  WebRTC使用两个预先存在的协议，数据报传输层安全（Datagram Transport Layer Security / DTLS）和 安全实时传输协议（Secure Real-time Transport Protocol / SRTP）。\nDTLS使您可以协商会话，然后在两个peer之间安全地交换数据。它是TLS的同类产品，TLS是HTTPS所使用的技术，而DTLS与TLS的区别仅在与其使用UDP而不是TCP作为其传输层。这也意味着DTLS协议必须处理不可靠的数据传输。SRTP是专为安全的交换媒体数据而设计的。相对于DTLS而言，使用SRTP对传输媒体数据有一些优化。\nDTLS先被使用。它通过ICE提供的连接进行一次握手。DTLS是一种客户端/服务器协议，因此其中一侧需要开始握手。客户端/服务器的角色是在信令中被确定的。在DTLS握手期间，双方都会提供证书。 握手完成后，需要将收到的证书与会话描述中的证书哈希进行比较。这是为了确定握手的目标就是您所期望的WebRTC代理。接下来，可以将DTLS连接用于DataChannel通信。\n要创建SRTP会话，我们使用DTLS生成的密钥对其进行初始化。SRTP没有握手机制，因此必须使用外部密钥进行引导。一旦完成此操作，媒体数据即可以用SRTP加密并进行交换！\n安全性101 #  要了解本章介绍的技术，您首先需要了解这些术语。密码学是一个棘手的主题，因此其他资源也是值得参考的！\nCipher #  Cipher是将明文转换为密文的一系列步骤。Cipher可以反过来运行，因此您可以将密文恢复为明文。一个Cipher通常拥有一个更改其行为的密钥。还有一个术语是加密和解密。\n举例来说，一个简单的cipher是ROT13。也就是每个字母向前移动13个字符。要解密这个cipher，需要每个字母向后移动13个字符。明文HELLO将成为密文URYYB。 在这种情况下，Cipher是ROT，密钥是13。\n明文/密文 #  明文是cipher的输入。密文是cipher的输出。\n哈希 #  哈希是一种生成摘要的单向过程。给定一个输入，它每次都会生成相同的输出。其重要特点是输出不可逆。也就是说，根据输出的摘要，无法确定其输入。当您要确认消息未被篡改时，哈希很有用。\n举例来说，一个简单的哈希将是仅将所有其他字母HELLO变成HLO。您不能认为HELLO就是输入，但可以确认如果输入的是HELLO，那么结果是匹配的。\n公钥/私钥加密 #  公钥/私钥加密描述了DTLS和SRTP使用的cipher类型。在此系统中，您有两个密钥，即公钥和私钥。公钥用于加密消息，可以安全共享。 私钥用于解密消息，永远不应共享。当解密那些使用对应的公钥加密的消息时，它是唯一的密钥。\nDiffie-Hellman交换 #  Diffie-Hellman交换允许两个以前从未见过的用户通过Internet安全的创建一个共享的秘密信息。用户A可以将秘密信息发送给用户B，而不必担心被窃听。破解该信息的难度将取决于破解离散对数问题的难度。 您不必完全理解该算法是如何工作的，但这可以帮助您了解是什么使得DTLS握手变得可行的。\nWikipedia在此处中有一个实际的例子。\n伪随机函数（PRF） #  伪随机函数是一个预定义函数，用于生成随机出现的值。它可能需要多个输入并生成一个输出。\n密钥派生（KDF） #  密钥派生是一类伪随机函数。是一种用于增强密钥的安全性的方法。一种常见的模式是密钥扩展。\n假设您获得的密钥为8字节。您可以使用KDF使其更坚固。\nNonce #  Nonce是cipher的附加输入。这样，即使您多次加密同一条消息，也可以从cipher中获得不同的输出。\n如果将同一条消息加密10次，cipher将为您提供10次相同的密文。通过使用nonce，在使用同一个密钥的情况下，您将得到不同的输入。需要注意的是，每条消息都要使用不同的nonce！ 否则就没有什么意义了。\n消息身份验证代码（Message Authentication Code） #  消息身份验证代码（MAC）是放在消息末尾的哈希值。MAC能证明该消息来自您期望的用户。\n如果您不使用MAC，攻击者可能会插入无效的消息。因为他们不知道密钥，所以这些消息解密后是无意义的垃圾内容。\n密钥轮换 #  密钥轮换是一种间隔一段时间便更改密钥的做法。这种做法会使得被窃取的密钥影响较小。如果密钥被窃取或泄漏，那么只有很少的数据可以被解密。\nDTLS #  DTLS（数据报传输层安全协议）允许两个peer在没有预先存在的配置的情况下建立安全的通信。即使有人窃听了通信，他们也将无法解密消息。\n为了使DTLS客户端和服务器进行通信，他们需要就cipher和密钥达成一致。他们通过进行DTLS握手来确定这些值。在握手期间，消息为纯文本格式。 当DTLS客户端/服务器交换了足够的详细信息以开始加密时，它会发送Change Cipher Spec（更改Cipher规格）消息。在此消息之后，后续的每个消息都将会被加密！\n数据包格式 #  每个DTLS数据包开头都包含一个头部信息。\n内容类型 #  您可以看到数据包包括以下几种类型：\n Change Cipher Spec（更改Cipher规格） - 20 Handshake（握手） - 22 Application Data（应用程序数据） - 23  握手用于交换详细信息以开始会话。 更改Cipher规格用于通知另一端所有内容都将被加密。应用程序数据是加密的消息。\n版本 #  版本可以是0x0000feff（DTLS v1.0）或0x0000fefd（DTLS v1.2），没有v1.1。\nEpoch（时段） #  时段从0开始，但在更改Cipher规格之后变为1。在非零时段的任何消息都将被加密。\n序列号 #  序列号用于保持消息顺序。每条消息都会增加序列号。当时段增加时，序列号重新开始。\n长度和有效载荷 #  有效载荷是特定于内容类型的。 对于应用程序数据，有效载荷是加密的数据。 对于握手，它会根据消息而有所不同。\n长度是指有效载荷的大小。\n握手状态机 #  在握手期间，客户端/服务器交换一系列消息。这些消息被分为多个Flight。每个Flight中可能有多个消息（或只有一个）。 直到收到Flight中的所有消息，该Flight才算完成。我们将在下面更详细地描述每条消息的目的，\n mermaid.initialize({ \"flowchart\": { \"useMaxWidth\":true }, \"theme\": \"default\" } ) sequenceDiagram participant C as Client participant S as Server C-S: ClientHello Note over C,S: Flight 1 S-C: HelloVerifyRequest Note over C,S: Flight 2 C-S: ClientHello Note over C,S: Flight 3 S-C: ServerHello S-C: Certificate S-C: ServerKeyExchange S-C: CertificateRequest S-C: ServerHelloDone Note over C,S: Flight 4 C-S: Certificate C-S: ClientKeyExchange C-S: CertificateVerify C-S: ChangeCipherSpec C-S: Finished Note over C,S: Flight 5 S-C: ChangeCipherSpec S-C: Finished Note over C,S: Flight 6 ClientHello #  ClientHello是客户端发送的初始消息。它包含一个属性列表。这些属性告诉服务器客户端支持的cipher和功能。对于WebRTC，这也是我们选择SRTP cipher方式的原因。它还包含将用于生成会话密钥的随机数据。\nHelloVerifyRequest #  服务器将HelloVerifyRequest发送到客户端。这是为了确认客户端准备继续发送请求。然后，客户端重新发送ClientHello，但这一次需要携带HelloVerifyRequest中提供的令牌。\nServerHello #  ServerHello是服务器响应消息，是此次会话的配置信息。它包含此会话直到结束时将使用的cipher。它还包含服务器端的随机数据。\nCertificate #  Certificate包含客户端或服务器的证书。它被用来唯一识别我们与之通信的对方。握手结束后，我们将确保这个证书的哈希与SessionDescription中的指纹相匹配。\nServerKeyExchange/ClientKeyExchange #  这些消息用于传输公共密钥。在启动时，客户端和服务器都会生成密钥对。握手后，这些值将被用来生成Pre-Master Secret。\nCertificateRequest #  CertificateRequest由服务端发送，用来通知客户端需要一个证书。服务端既可以请求一个证书，也可以要求必须提供证书。\nServerHelloDone #  ServerHelloDone通知客户端此时服务器已完成握手动作。\nCertificateVerify #  发送者用CertificateVerify消息来证明他已经获得了Certificate消息中发送的私钥。\nChangeCipherSpec #  ChangeCipherSpec通知接收者在此消息之后发送的所有内容都将被加密。\nFinished #  Finished消息是加密的，它包含所有消息的哈希。用来断言握手过程未被篡改。\n密钥的生成 #  握手完成后，您可以开始发送加密数据。Cipher是由服务器选择的，位于ServerHello消息中。但接下来如何生成密钥呢？\n首先，我们需要生成Pre-Master Secret。为了获得该值，我们通过ServerKeyExchange和ClientKeyExchange消息，使用Diffie-Hellman算法来交换密钥。细节因选定的Cipher而异。\n接下来，生成Master Secret。每个版本的DTLS都有一个定义的Pseudorandom function（伪随机函数）。对于DTLS 1.2，伪随机函数会在ClientHello和ServerHello中获取Pre-Master Secret和随机值。 运行Pseudorandom function后，获得的输出是Master Secret。Master Secret是用于Cipher的值。\n交换ApplicationData #  DTLS的主要内容是ApplicationData。现在我们有了一个初始化好的Cipher，我们可以开始加密和发送数据了。\n如前所述，ApplicationData消息使用一个DTLS标头。Payload中填充了密文。您现在可以正常使用DTLS会话，并且可以安全地进行通信。\nDTLS具有更多有趣的功能，例如重新协商等。WebRTC中不使用这些功能，因此此处不作介绍。\nSRTP #  SRTP是针对加密RTP数据包专门涉及的协议。要启动SRTP会话，需要指定密钥和cipher。与DTLS不同，它没有握手机制。所有的配置和密钥都是在DTLS握手期间生成的。\nDTLS提供了专用的API，用来导出密钥以供另一个进程使用。这是在RFC 5705中定义的\n会话创建 #  SRTP定义了一个密钥派生函数，用于处理输入。在创建SRTP会话时，密钥派生函数将被执行，用输入数据生成SRTP Cipher的密钥。之后，您可以继续处理媒体。\n交换媒体数据 #  每个RTP数据包都有一个16位的SequenceNumber（序列号）。这些序列号用于使数据包保持顺序，就像主键一样。在通话期间，这些序列号将滚动累加。SRTP会对其进行跟踪，并将其称为滚动计数器。\n加密数据包时，SRTP使用滚动计数器和序列号作为nonce。这是为了确保即使两次发送相同的数据，密文也会有所不同。这样做很重要，可以阻止攻击者识别模式或尝试重播攻击。\n"});index.add({'id':4,'href':'/zh/docs/05-real-time-networking/','title':"实时联网",'section':"Docs",'content':"TODO\n"});index.add({'id':5,'href':'/zh/docs/06-media-communication/','title':"媒体通信",'section':"Docs",'content':"我可以从WebRTC的媒体通信中得到什么？ #  WebRTC允许您发送和接收无限多条音频和视频流。您可以在通话期间随时添加和删除这些流。这些流可以全部独立，也可以捆绑在一起！您甚至可以将网络摄像头的音频/视频放到您桌面的视频流中，然后将此视频流以feed的形式发送出去。\nWebRTC协议与编解码器无关。底层传输支持所有格式的内容，即使是还不存在的格式！ 但是，您正与之通信的WebRTC代理可能没有必要的工具来接受它。\nWebRTC针对动态网络状况也有对应的处理方案。在通话过程中，带宽可能会增加或减少。 甚至可能突然间大量丢包。该协议对所有这类问题的处理都做了相应的设计。WebRTC根据网络状况作出响应，并尝试利用可用资源为您提供最佳体验。\n它是如何工作的？ #  WebRTC使用RFC 1889中定义的两个既有协议RTP和RTCP。\nRTP（实时传输协议/Real-time Transport Protocol）是承载媒体的协议。它为视频的实时传输而设计。它没有规定有关延迟或可靠性的任何规则，但是为您提供了实现这些规则的工具。RTP提供了流的设计，因此您可以通过一个连接发布多个媒体源。它还为您提供了完善媒体传递途径所需的计时和排序信息。\nRTCP（RTP控制协议/RTP Control Protocol）是用于传达有关呼叫的元数据的协议。其格式非常灵活，并允许您可以添加所需的任何元数据。这点被用来传达有关呼叫的统计信息。也是处理分组丢失和实现拥塞控制的必备特性。它为您提供了响应变化的网络状况所必需的双向通信能力。\n延迟与质量 #  实时媒体就是要在延迟和质量之间进行权衡。您愿意忍受的延迟时间越长，可以预期的视频质量就越高。\n现实世界的局限性 #  下面这些限制都是由现实世界的局限性引起的。它们都是您需要考虑的网络特性。\n带宽 #  带宽是可以在给定路径上传输的最大数据速率。注意这不是一个静态数字，这一点很重要。随着越来越多（或越少）的人使用路由，带宽将发生变化。\n当您尝试发送的数据超过可用带宽时，您将遇到网络拥塞的情况。\n传输时间 #  传输时间指的是一个数据包到达目标需要多长时间。像带宽一样，这不是常量。传输时间随时可能波动。\n抖动 #  抖动是传输时间可能会变化导致的现象。有时您会看到收到的数据包突然爆炸式增加。网络路径上的任何硬件都可能引入这个问题。\n数据包丢失 #  数据包丢失是指消息在传输中丢失。丢失率可能是稳定的，也可能突然增加。这也是一个常见的情况，特别是在无线网络上！\n最大传输单位（Maximum transmission unit/MTU） #  最大传输单位是指单个数据包的最大限制。您无法在网络上发送一个巨大的消息。在协议级别上，您需要将数据分成多个小数据包。\n根据您采用的网络路径，MTU也将有所不同。您可以使用Path MTU Discovery之类的协议来确定可以发送的最大的数据包大小。\nMedia 101（媒体格式基础知识） #  Codec（编解码器） #  Frame Types（帧类型） #  RTP #  Packet Format（包格式） #  每个RTP数据包都具有以下结构：\n 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |V=2|P|X| CC |M| PT | Sequence Number | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Timestamp | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Synchronization Source (SSRC) identifier | +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ | Contributing Source (CSRC) identifiers | | .... | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Payload | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Version (V) #  Version总是2。\nPadding (P) #  Padding是控制有效载荷是否具有填充值的布尔值。\n有效负载的最后一个字节包含添加了多少填充字节的计数。\nExtension (X) #  如果设置的话，RTP报头将有扩展段（可选）。这点将在下面更详细地描述。\nCSRC count (CC) #  在SSRC之后，有效负载之前的CSRC标识符的数量。\nMarker (M) #  标记位没有预设含义，由用户决定。\n在某些情况下，它是在用户讲话时设置的。它还通常用于标记关键帧。\nPayload Type (PT) #  Payload Type（负载类型）是此数据包所承载的编解码器的一个唯一标识符。\n对于WebRTC，Payload Type是动态的。一个呼叫中的VP8的PT可能与另一个呼叫中的不同。呼叫中的Offerer确定Payload Type到Session Description（会话描述符）中的编解码器的映射。\nSequence Number #  Sequence Number（序列号）用于对流中的数据包进行排序。每次发送数据包时，Sequence Number都会增加1。\nRTP被设计为可以在有损网络上使用。这为接收器提供了一种检测数据包何时丢失的方法。\nTimestamp #  此数据包的采样时刻。这不是全局时钟，而是在当前媒体流中所经过的时间。\nSynchronization Source (SSRC) #  SSRC是此流的唯一标识符。 这使您可以在单个流上传输多个媒体流。\nContributing Source (CSRC) #  一个列表，用于表示哪些SSRC参与到了这个数据包中。\n这通常用于语音指示器。假设在服务器端，您将多个音频源组合到一个单独的RTP流中。然后，您可以在此字段中表示输入流A和C此时正在讲话。\nPayload #  实际有效负载数据。如果设置了填充（padding）标记，则可能以添加的填充字节数结尾。\nExtensions（扩展） #  Mapping Payload Types to Codecs（将负载类型映射到编解码器） #  RTCP #  Packet Format #  每个RTCP数据包都具有以下结构：\n 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |V=2|P| RC | PT | length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Payload | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Version (V) #  Version总是2。\nPadding (P) #  Padding是控制有效载荷是否具有填充值的布尔值。\n有效负载的最后一个字节包含添加了多少填充字节的计数。\nReception Report Count (RC) #  此数据包中的报告数。单个RTCP数据包可以包含多个事件。\nPacket Type (PT) #  指示RTCP数据包类型的唯一标识符。WebRTC代理不需要支持所有这些类型，并且代理之间的支持能力可以是不同的。下面这些是您可能经常看到的类型。\n 完整的帧内请求（FIR）-192 否定确认（NACK）-193 发送方报告-200 接收方报告-201 通用RTP反馈-205  这些分组类型的意义将在下面更详细地描述。\nFull INTRA-frame Request（完整的帧内请求） #  此RTCP消息通知发送者它需要发送完整图像。这适用于编码器为您提供了帧的一部分，但您无法对其进行解码的情况。\n之所以会发生这种情况，是因为您有很多数据包丢失，或者解码器崩溃了。\nNegative ACKnowledgements（否定确认） #  NACK请求发送方重新发送单个RTP数据包。这通常是由于RTP数据包丢失而引起的，但是也可能由于延迟而发生。\n与请求重新发送整个帧相比，NACK的带宽效率要高得多。由于RTP将数据包分解成很小的块，因此您实际上只是在请求丢失的一个很小的部分。\nSender/Receiver Reports（发送方/接收方报告） #  这些报告用于在代理之间发送统计信息。它传达了实际接收到的和抖动的数据包数量。\n这些报告可用于诊断或者基本的拥塞控制。\nGeneric RTP Feedback（通用RTP反馈） #  RTP/RTCP是如何解决问题的 #  RTP和RTCP需要协同解决网络引起的所有问题。这些技术仍在不断进化中！\nNegative Acknowledgment（否定确认） #  也称为NACK。这是使用RTP处理数据包丢失的一种方法。\nNACK是回给发送方以请求重发的RTCP消息。接收方使用SSRC和序列号制作RTCP消息。如果发送方没有可用于重新发送的RTP数据包，则忽略该消息。\nForward Error Correction（前向纠错） #  简称为FEC。处理丢包的另一种方法。FEC指的是发送方多次重复发送相同的数据，甚至是在接收方没有要求的情况下发送。这是在RTP协议层级完成的，甚至也可以在编解码器以下的层级完成。\n在呼叫的数据丢包率比较稳定的情况下，作为延迟处理方案，FEC比NACK好的多。对于NACK，必须先请求，然后重新传输数据包，数据往返的时间对性能的影响可能是很明显的。\n自适应比特率和带宽估计 #  现代IP网络（包括无线和有线网络）的一个普遍问题是不可预测和不可靠的带宽。在整个会话过程中，网络条件可能会多次动态变化。在一秒钟之内看到可用的带宽急剧变化（差别达到数量级），这样的情况并不少见。\n有线网络的不可预测性可能是由于网络带宽需求的变化，路由更改，传输介质（光纤通道，以太网，dsl）的限制等引起的。\n除了在有线网络中存在的问题之外，无线电信号传输本身的特性，来自多个源的干扰，到手机信号塔或Wi-Fi接入点的距离以及物理障碍（阅读墙）也是导致无线网络特征无法预测的一些原因。\nWebRTC具有多种机制，即使网络条件发生变化，也可以帮助将视频/音频信号顺利发送给接收方。 其主要思路是根据预测的，当前的和将来的可用网络带宽来调整编码比特率。 这样可以确保传输质量最佳的视频/音频信号，并且不会因为网络拥塞而断开连接。 对网络行为建模并尝试对其进行预测的启发式方法称为带宽估计。\nREMB（Receiver Estimated Maximum Bitrate/接收方估计的最大比特率） #  一种曾被广泛应用，却从未被完整标准化，现在被认为已弃用的方法，叫做REMB (接收方估计的最大比特率)。 REMB是接收方发给发送方的特殊RTCP数据包，用来通知发送方可用的带宽。对于估计REMB相关的带宽问题，没有标准的方法定义（存疑），因此实际的带宽值是跟不同实现相关的。研究REMB细节的一个很好的起点是Chrome源码。\n数据包中唯一有用的负载是比特率，以每秒比特数为单位。 造成明显的歧义和混淆的根源是，REMB中的比特率被定义为 total（全部的） 比特率，而WebRTC库通常仅仅使用它来限制视频编码。\n  Congestion Control（拥塞控制） #  经验丰富的WebRTC业内人士声称，用REMB的方式（实现拥塞控制），给WebRTC只留下了伤疤，愤怒的表情，乃至Google工程师的耻笑。\n拥塞控制是根据网络属性调整媒体的行为。如果带宽较小，则需要发送质量较低的视频。\n拥塞控制通过提供更细粒度的控制以及对网络连接和状况的监视来改善WebRTC体验。\nTWCC（Transport-Wide Congestion Control/传输范围内的拥塞控制） #  传输范围内的拥塞控制（TWCC）是在大多数浏览器中实现的高级拥塞控制规范。\nTWCC使用一个非常简单的原则：\n  与REMB不同，TWCC的接收方不会尝试估计自己的传入比特率。它只是让发送方知道哪些包在何处及何时被接收。基于这些报告，发送方可以了解网络的最新的状况。\n 发送方创建带有特殊的TWCC标头扩展的RTP数据包，其中包含一个数据包序列号的列表。 接收方以特殊的RTCP反馈消息进行响应，以使发送方知道每个数据包是否以及何时被接收。  发送方跟踪已发送的数据包，包括它们的序列号，大小和时间戳。 当发送方从接收方收到RTCP消息时，它将发送数据包间的延迟与接收延迟进行比较。 如果接收延迟增加，则意味着网络正在发生拥塞，发送者必须对此采取行动。\n在下图中，数据包间延迟的中位数增长了+20毫秒，这清楚地表明网络正在发生拥塞。\n  TWCC提供了原始数据和实时网络状况的绝佳视图：\n 几乎是即时的丢包统计信息，不仅包括丢失的百分比，还包括丢失的确切数据包。 准确的发送比特率。 准确的接收比特率。 抖动估计。 发送和接收数据包延迟之间的差异。  一种简单的，用于估计从发送方到接收方的传输比特率的拥塞控制算法是，将接收到的数据包大小相加，然后将其除以接收方一端经过的时间。\n更复杂的拥塞控制算法建立在原始的TWCC数据的基础上，例如：一种用于实时通信的Google拥塞控制算法，简称GCC，由Google提出并在Chrome中实现。 它通过使用Kalman过滤器预测当前和将来的网络带宽。\n还有几种GCC的替代品，例如：NADA：一种实时媒体的统一拥塞控制方案 和 SCReAM- 多媒体的自时钟速率自适应。\n问：我如何知道TWCC已被支持并启用？\n答：查看SDP offer/answer。如果您看到以下几行，则说明您的连接已经协商并启用了TWCC：\na=extmap:5 http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions 以及\na=rtcp-fb:96 transport-cc JitterBuffer（抖动缓冲） #  "});index.add({'id':6,'href':'/zh/docs/07-data-communication/','title':"数据通信",'section':"Docs",'content':"什么是数据 #  功能概述 #  数据通道可以传送任何类型的数据。您也可以通过数据通道发送音频或视频数据，但是如果需要实时播放媒体，使用基于RTP/RTCP协议的媒体通道是更好的选择（请参阅媒体通信）。\n数据通道有哪些应用？ #  数据通道的适用性是无限的！数据通道为您解决了数据包丢失，拥塞问题和许多其他问题。它提供了非常简单的API，让您将数据实时交付给对端peer。您只需要关注应用程序想要实现的目标即可。\n以下是一些使用数据通道的示例应用：\n 实时网络游戏 远程无服务器家庭自动化 文字聊天 动画（一系列静止图像） P2P CDN（内容交付网络） 监控物联网数据 从传感器设备持续提取时间序列数据 从相机获取实时图像并利用AI进行图像识别  协议栈概述 #  数据通道由以下3层组成：\n 数据通道层 DCEP（数据通道建立协议）层 SCTP（流控制传输协议）层    数据通道层 #  该层提供了API。该API大体上是对WebSocket的模拟，从而使Web开发人员能相对容易的将现有的基于WebSocket的客户端-服务器的代码修改为使用P2P数据通道实现。单一的peer连接可以包含peer之间的多条数据通道，从而省去了从多个数据源和接收器复用和解复用的麻烦。只需要为交换的每一类数据创建一个数据通道，其余的工作都交给peer连接完成。与WebSockets不同的一点是，数据通道具有创建者分配的标签，接收者可以使用标签来确定数据通道的身份。\n数据通道建立协议层 #  该层负责与对端peer建立数据通道握手。它使用SCTP流作为控制通道来协商诸如有序交付，maxRetransmits（最大重传）/ maxPacketLifeTime（最大包生命周期）（也就是\u0026quot;部分可靠性\u0026quot;选项），发送频道的标签等等。\nSCTP协议层 #  这是数据通道的核心。它包括：\n 通道复用（在SCTP中，通道称为\u0026quot;流\u0026rdquo;） 使用类似TCP的重传机制进行可靠传递 部分可靠性选项 避免拥塞 流量控制  Data Channel API #  Connection / Teardown #  Data Channel Options #  Flow Control API #  Data Channel in Depth #  SCTP #  Connection establishment flow #  Connection teardown flow #  Keep-alive mechanism #  How does a user message get sent? #  TSN and retransmission #  Congestion avoidance #  Selective ACK #  Fast retransmission/recovery #  Partial Reliability #  DCEP（Data Channel Establishment Protocol/数据通道建立协议） #  DCEP是一个简单到只有两个数据包的协议，它描述了建立数据通道的行为。它不需要等待握手完成，因此该通道的后续数据可以包含在同一数据包中。这使得建立数据通道更加快速，而且成本更低。\nOpen/ACK handshake（握手） #  0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Message Type | Channel Type | Priority | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Reliability Parameter | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Label Length | Protocol Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ \\ / | Label | / \\ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ \\ / | Protocol | / \\ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 这里是通道类型以及相关的可靠性参数的列表，在数据包丢失或乱序接收时，可以调整这些参数。\nDATA_CHANNEL_OPEN Message Type: 0x03 +================================================+=============+ | Channel Type | Reliability | | | Parameter | +================================================+=============+ | DATA_CHANNEL_RELIABLE | Ignored | +------------------------------------------------+-------------+ | DATA_CHANNEL_RELIABLE_UNORDERED | Ignored | +------------------------------------------------+-------------+ | DATA_CHANNEL_PARTIAL_RELIABLE_REXMIT | Number of | | | RTX | +------------------------------------------------+-------------+ | DATA_CHANNEL_PARTIAL_RELIABLE_REXMIT_UNORDERED | Number of | | | RTX | +------------------------------------------------+-------------+ | DATA_CHANNEL_PARTIAL_RELIABLE_TIMED | Lifetime in | | | ms | +------------------------------------------------+-------------+ | DATA_CHANNEL_PARTIAL_RELIABLE_TIMED_UNORDERED | Lifetime in | | | ms | +------------------------------------------------+-------------+ 数据通道的可靠性大体上等同于TCP。\n需要特别提一下Reliable_Unordered。这种模式意味着，如果一个数据包因为网络原因丢失时，只有包含这个数据包的消息会被延后，直到重新发送为止。在这个消息之后发送的其他消息可能会更早到达。当接收消息的顺序不如消息到达的速度重要时，就可以使用这种模式。在这种模式下，仍然强制执行消息传递，但传递顺序不是强制的。可以将这种模式视为TCP和UDP之间的折衷方案。\n其他的模式等价于基于UDP，但具有不同的重试/失败规则的协议。\nDATA_CHANNEL_ACK Message Type: 0x02 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Message Type | +-+-+-+-+-+-+-+-+ 没有DCEP NACK（译注：即数据通道建立失败）。 数据通道的打开始终会成功，因为它们的传输是在已经成功建立的SCTP流上进行！\nPPID（Payload Protocol Identifier/有效载荷协议标识符） #  WebRTC DCEP的SCTP PPID为50。DCEP消息与SCTP流中的其余数据分开处理，并且不会传递回Web应用程序或服务。\n参数交换 #  理论上讲，可以使用out-of-band的SDP中非DCEP协商的方式来创建数据通道。不要这样。\nRFC链接 #  https://datatracker.ietf.org/doc/rfc8832/?include_text=1\n"});index.add({'id':7,'href':'/zh/docs/08-applied-webrtc/','title':"WebRTC应用场景",'section':"Docs",'content':"WebRTC应用场景 #  现在您已经知道WebRTC的工作原理，到了使用它的时候了。本章探讨人们使用WebRTC构建什么以及他们是如何实现的。您将学到基于WebRTC发生的所有有趣的事情。WebRTC的功能是有代价的。建立产品级的WebRTC服务相当有挑战性。本章将尝试解释这些挑战性的根源，这样您遇到问题时就能有所准备。\n用例 #  WebRTC背后的技术并不仅用于视频聊天 \u0026ndash; 由于WebRTC是通用的实时框架，因此应用可用的用例是无限的。一些最常见的类别包括：\n会议 #  会议是WebRTC最初设计的目标用例。您可以让两个用户直接相互连接。连接后，他们可以共享网络摄像头，也可以共享桌面。参与者可以发送和接收任意数量的流。他们还可以随时添加和删除这些流。\n除了传输媒体，数据通道对于提升会议体验也非常有用。用户可以发送元数据或共享文档。您可以创建多个流，并同时进行多个对话。\n随着更多用户加入呼叫，会议变得更加困难。如何扩展完全取决于您。WebRTC拓扑部分将对此作进一步介绍。\n广播 #  WebRTC也可以用于以一对多方式广播视频流。\n远程控制 #  文件传输 #  可以创建一个桌面应用程序来捕获屏幕截图。当设备A在剪贴板上获得截图后，它可以生成一个临时链接供其他设备访问。当设备B打开链接时，就可以与设备A建立PeerConnection，然后使用WebRTC的数据通道对数据进行流传输。一旦传输成功，连接就可以断开。这是一种通过Internet传输文件的安全有效的方式。\n分布式CDN #  物联网 #  当视频门铃检测到移动时，它可以向摄像机提供RTP流，并通过中央服务器启动一个新的PeerConnection以进行记录，或者向移动设备推送通知以要求其作为peer连接。这将在门铃和移动应用之间建立实时通信。该移动应用可以将实时音频发送回门铃，也可以通过WebRTC启动安全的远程控制。\n协议桥接 #  WebRTC拓扑 #  无论您是使用WebRTC的语音，视频还是DataChannel功能，一切都是从PeerConnection开始的。在任何WebRTC应用程序中，peer如何相互连接是关键的设计考虑因素，现在已有许多验证过的方法。\n客户端-服务器 #  WebRTC协议的低延迟特性非常适合通话，通常会看到以p2p网状配置（低延迟）安排会议，或者连接到SFU（选择性转发单元）以提高通话质量。由于编解码器支持因浏览器而异，因此许多会议服务器允许浏览器使用h264之类的专有或非免费编解码器进行广播，然后在服务器级别将其重新编码为VP8等开放标准。当SFU不仅执行转发数据包时执行编码任务时，它被称为MCU（多点会议单元）。尽管众所周知，SFU快速高效，非常适合举办会议，而MCU可能会占用大量资源！一些会议服务器甚至会执行更繁重的任务，例如为每个呼叫者定制的合成（组合）A/V流，以通过仅发送所有其他呼叫者的单个流来最大程度地减少客户端带宽的使用。\nSFU (选择性转发单元) #  MCU (多点会议单元) #  Peer-To-Peer #  One-To-One #  P2P Mesh #  "});index.add({'id':8,'href':'/zh/docs/09-debugging/','title':"调试",'section':"Docs",'content':"调试 #  调试WebRTC可能是一项艰巨的任务。有很多部分都处于运行状态，每一个部分都可能出现问题。如果您不够细心，可能会浪费数周的时间来查看错误的模块。当您最终找到出错的部分时，您还需要学习一些知识才能理解它。\n本章将带您学习WebRTC的调试。它将向您展示如何分析并定位相关问题。确定问题后，我们将快速介绍一下流行的调试工具。\n分解问题 #  开始调试时，您需要先分析问题的根源。\n信令故障 #  网络故障 #  使用netcat测试您的STUN服务器：\n  准备20字节的绑定请求数据包：\necho -ne \u0026quot;\\x00\\x01\\x00\\x00\\x21\\x12\\xA4\\x42TESTTESTTEST\u0026quot; | hexdump -C 00000000 00 01 00 00 21 12 a4 42 54 45 53 54 54 45 53 54 |....!..BTESTTEST| 00000010 54 45 53 54 |TEST| 00000014 解释：\n  00 01 是消息类型\n  00 00 是数据段的长度\n  21 12 a4 42 是magic cookie\n  54 45 53 54 54 45 53 54 54 45 53 54 （解码成ASCII就是TESTTESTTEST） 是12字节的transaction ID\n    发送请求并等待32字节的响应：\nstunserver=stun1.l.google.com;stunport=19302;listenport=20000;echo -ne \u0026quot;\\x00\\x01\\x00\\x00\\x21\\x12\\xA4\\x42TESTTESTTEST\u0026quot; | nc -u -p $listenport $stunserver $stunport -w 1 | hexdump -C 00000000 01 01 00 0c 21 12 a4 42 54 45 53 54 54 45 53 54 |....!..BTESTTEST| 00000010 54 45 53 54 00 20 00 08 00 01 6f 32 7f 36 de 89 |TEST. ....o2.6..| 00000020 解释：\n  01 01 是消息类型\n  00 0c 是数据段的长度，解码后是十进制的12\n  21 12 a4 42 是magic cookie\n  54 45 53 54 54 45 53 54 54 45 53 54 （解码成ASCII就是TESTTESTTEST）是12字节的transaction ID\n  00 20 00 08 00 01 6f 32 7f 36 de 89 是12字节的数据，解释：\n  00 20 是类型：XOR-MAPPED-ADDRESS\n  00 08 是value段的长度，以十进制解码就是8\n  00 01 6f 32 7f 36 de 89 是数据值，解释：\n  00 01 是地址类型（IPv4）\n  6f 32 是经过XOR映射的端口\n  7f 36 de 89 是经过XOR映射的IP地址\n        解码XOR映射的部分很麻烦，但是我们可以通过提供设置为00 00 00 00的（无效）伪magic cookie来诱骗stun服务器执行伪XOR映射：\nstunserver=stun1.l.google.com;stunport=19302;listenport=20000;echo -ne \u0026quot;\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00TESTTESTTEST\u0026quot; | nc -u -p $listenport $stunserver $stunport -w 1 | hexdump -C 00000000 01 01 00 0c 00 00 00 00 54 45 53 54 54 45 53 54 |........TESTTEST| 00000010 54 45 53 54 00 01 00 08 00 01 4e 20 5e 24 7a cb |TEST......N ^$z.| 00000020 对伪magic cookie的XOR运算是幂等的，因此响应中的端口和地址将是清楚的（这并非在所有情况下都有效，因为某些路由器会操纵传递的数据包，伪装IP地址）； 如果我们查看返回的数据值（最后八个字节）：\n  00 01 4e 20 5e 24 7a cb 是数据值，解释：\n  00 01 是地址类型（IPv4）\n  4e 20 是映射的端口，解码成十进制就是20000\n  5e 24 7a cb 是IP地址，解码成点分十进制表示法就是94.36.122.203\n    安全故障 #  媒体故障 #  数据故障 #  用到的工具 #  netcat (nc) #  netcat 是用于使用TCP或UDP读取和写入网络连接的命令行网络实用程序。通常它可以用nc命令来调用。\ntcpdump #  tcpdump是一个命令行数据网络数据包分析器。\n常用命令：\n  捕获与端口19302之间的UDP数据包，并打印数据包内容的十六进制转储：\nsudo tcpdump \u0026lsquo;udp port 19302\u0026rsquo; -xx\n  与上一条相同，但将数据包保存在PCAP（数据包捕获）文件中以供以后检查\nsudo tcpdump \u0026lsquo;udp port 19302\u0026rsquo; -w stun.pcap\n可以使用wireshark GUI打开PCAP文件：wireshark stun.pcap\n  wireshark #  webrtc-internals #  "});index.add({'id':9,'href':'/zh/docs/10-history-of-webrtc/','title':"历史",'section':"Docs",'content':"历史 #  本节仍在进行中，我们还没有还原全部事实。我们正在进行采访并修订数字通信的历史。\nRTP #  RTP和RTCP是处理WebRTC的所有媒体传输的协议。它是在1996年1月的RFC 1889中定义的。 我们很幸运地邀请一位作者Ron Frederick自己谈论这个问题。 罗恩最近上传了 Network Video tool，一个展示了RTP的项目。\n用他自己的话说：\n在1992年10月，我开始尝试使用Sun VideoPix帧采集卡，当时的想法是编写一个基于IP多播的网络视频会议工具。它是根据\u0026quot;vat\u0026quot;建模的，\u0026ldquo;vat\u0026quot;是LBL开发的一个音频会议工具，它为参加会议的用户使用了类似的轻量级会话协议，您可以简单地使用此工具将数据发送到特定的多播组，并监听来自该组中其他小组成员的任何流量。\n为了使程序真正成功，它需要先压缩视频数据，然后再将其发布到网络上。我的目标是在大约128 kbps或标准家庭ISDN线路的带宽上生成可接受的可视数据流。我还希望在一半带宽下生成仍能被观看到的东西。这意味着我需要将特定图像尺寸和帧率的视频压缩到大约20分之一的大小。我实现了这种压缩，并申请了专利，专利是 US5485212A：用于电话会议的软件视频压缩。\n1992年11月上旬，我向互联网社区发布了视频会议工具\u0026quot;nv\u0026rdquo;（二进制形式）。经过一些初步测试后，它被用于在全球范围内对11月Internet工程任务组的部分进行视频广播。在15个国家/地区中，大约有200个子网能够接收此广播，并且一周中的某个时候，大约有50-100人使用\u0026quot;nv\u0026quot;接收了视频。\n在接下来的几个月中，另外三个研讨会和一些较小的会议使用\u0026quot;nv\u0026quot;向整个Internet进行广播，包括澳大利亚NetWorkshop，MCNC分组音频和视频研讨会以及瑞典的分布式虚拟现实MultiG研讨会。\n随后，在1993年2月，我发布了\u0026quot;nv\u0026quot;的源代码，并在3月发布了该工具的一个版本，在其中引入了新的基于小波的压缩方案。在1993年5月，我增加了对彩色视频的支持。\n用于\u0026quot;nv\u0026quot;和其他Internet会议工具的网络协议成为了实时传输协议（RTP）的基础，该协议通过Internet工程任务组（IETF）进行了标准化，该工作组首先在RFCs 1889-1890中发布，后来又与其他各种RFC一起，在RFCs 3550-3551中进行了修订，它们涵盖了用于传递特定音频和视频格式的配置文件。\n在接下来的几年中，关于\u0026quot;nv\u0026quot;的工作继续进行，该工具被移植到了许多其他硬件平台和视频捕获设备上。它仍然被用作当时在Internet上广播会议的主要工具之一，包括被NASA选中以在线直播的方式进行航天飞机飞行任务的实时报道。\n1994年，我在\u0026quot;nv\u0026quot;中添加了对其他人开发的视频压缩算法的支持，其中包括一些硬件压缩方案，如SunVideo视频捕获卡支持的CellB格式。这也使得\u0026quot;nv\u0026quot;可以用CUSeeMe格式发送视频，并将视频发送给在Mac和PC上运行CUSeeMe的用户。\n最新的\u0026quot;nv\u0026quot;版本是1994年7月发布的3.3beta版本。当时我正在开发\u0026quot;4.0alpha\u0026quot;版本，该版本旨在将\u0026quot;nv\u0026quot;迁移到RTP协议v2，但因为我转到了其他项目上，这项工作从未被完成。为了保持完整性，Network Video tool归档文件中包含4.0 alpha代码的副本，但它是未完成的，并且存在已知问题，尤其是在RTPv2支持不完整的情况下。\n\u0026ldquo;nv\u0026quot;中提供的框架后来成为Xerox PARC的\u0026quot;Jupiter multi-media MOO\u0026quot;项目中视频会议的基础，该项目最终分拆为独立公司\u0026quot;PlaceWare\u0026rdquo;，后来该公司被Microsoft收购。它也被用作许多硬件视频会议项目的基础，这些项目允许通过高带宽以太网和ATM网络发送完整的NTSC广播质量的视频。后来我还使用了其中一些代码作为\u0026quot;Mediastore\u0026quot;的基础，\u0026ldquo;Mediastore\u0026quot;是基于网络的视频记录和回放服务。\n您还记得草案中其他人的动机/想法吗？\n我们都是IP多播的研究人员，并且帮助创建了Internet多播主干网（又名MBONE）。MBONE由Steve Deering（IP多播的首位开发者），Van Jacobson和Steve Casner创建。 我和Steve Deering在斯坦福大学有同一位顾问，Steve离开斯坦福大学后就去了Xerox PARC工作，我作为IP多播相关项目的实习生在Xerox PARC呆了一个夏天，后来在斯坦福大学还继续为他们兼职工作，再后来转为全职。Van Jacobson和Steve Casner是最初的RTP RFC的四位作者中的两位，还有Henning Schulzrinne和我本人。我们所有人都使用MBONE工具进行各种形式的在线协作，并且试图提炼出所有这些工具可以使用的通用基本协议，RTP就是这样出现的。\n多播很棒。而WebRTC完全是单播的，可以说一下是为什么吗？\n在前往斯坦福大学并学习IP多播之前，我花了很长时间致力于让计算机成为人们相互交流的方式。这是从80年代初期开始的，当时我运行了一个拨号公告板系统，人们可以登录并留下彼此的消息，既可以是私人的（相当于电子邮件），也可以是公共的（讨论小组）。大约在同一时间，我还了解了在线服务提供商CompuServe。 CompuServe的很酷的功能之一就是所谓的\u0026quot;CB Simulator\u0026rdquo;，人们可以在其中进行实时交谈。这些都是基于文本的，但是它具有\u0026quot;频道\u0026quot;的概念，就像真正的CB广播一样，只要他们在同一个频道中，大家就可以看到其他人键入的内容。我构建了自己的CB版本，该版本在我可以访问的分时共享系统上运行，该系统可以让该系统上的用户实时向彼此发送消息，然后在接下来的几年中，我与朋友一起开发了更复杂的各种版本的实时通信工具，可以在几个不同的计算机系统和网络上运行。事实上，其中一个系统仍在运行，我每天都会用它与30多年前上大学的人们进行交流！\n所有这些工具都是基于文本的，因为当时的计算机通常没有任何音频/视频功能，但是当我到达斯坦福大学并学习了IP多播时，我产生了一个想法。做一个真正的\u0026quot;收音机\u0026rdquo;，您可以将信号发送到网络上，该信号并不特别针对任何人，但是调谐到该\u0026quot;频道\u0026quot;的每个人都可以接收到它。碰巧，我正在给Sun的第一代SPARCstation移植IP多播代码，而这一设备实际上具有内置电话质量的音频硬件！您可以将麦克风中的声音数字化，然后通过内置扬声器（或通过耳机输出）播放。 因此，我的第一个想法是弄清楚如何使用IP多播将音频实时发送到网络上，然后看一下是否可以构建一个使用实际音频而不是文本的\u0026quot;CB收音机\u0026rdquo;。\n这里有一些棘手的事情需要解决，例如计算机一次只能播放一个音频流，因此，如果有多个人在讲话，则需要在数学上将多个音频流\u0026quot;混合\u0026quot;为一个，然后才能播放。不过一旦您了解了音频采样的工作原理，这些工作就可以全部通过软件完成。该音频应用程序使我致力于MBONE的开发，并最终通过\u0026quot;nv\u0026quot;实现了到视频的转换。\n协议中遗漏了什么您原本希望添加的东西吗？有没有哪些让您后悔加入的内容？\n我不觉得有什么后悔的，不过最终人们对RTP抱怨最多的其中一点就是RTCP实现的复杂性，RTCP是与RTP主数据流量并行运行的控制协议。我认为，RTP并未得到更广泛采用的主要原因就是太过复杂，尤其是在单播情况下，对RTCP的某些功能的需求不再那么大。由于网络带宽变得不再那么稀缺，而拥塞也不再是一个大问题，许多人最终只是通过纯TCP（以及后来的HTTP）流式传输音频和视频，一般来说，这就已经\u0026quot;足够好\u0026quot;了，以至于没有必要再去与RTP打交道。\n不幸的是，使用TCP或HTTP意味着多方音频和视频应用程序必须通过网络多次向需要接收数据的每个对等方发送相同的数据，从而从带宽的角度来看，效率被大大降低。有时，我希望我们之前能更加努力地推动IP多点广播的应用，使其不仅限于研究领域。我认为，如果我们这么做了的话，可能我们早就可以看到有线电视和广播电视过渡到基于Internet的音频和视频。\n有什么东西是您曾经想过使用RTP构建的呢？是不是有一些很酷的RTP项目/想法随时间流逝了呢？\n我构建的其中一个有趣的项目是一个使用IP多播的经典游戏\u0026quot;Spacewar\u0026quot;版本。在没有任何类型的中央服务器的情况下，多个客户端可以各自运行spacewar的二进制文件，并开始广播其船舶的位置/速度/所面对的方向以及已发射的任何\u0026quot;子弹\u0026quot;的类似信息，所有其他客户端将收集这些信息并将其呈现在本地，从而使所有人都可以看到彼此的飞船和子弹，如果飞船撞向对方或被子弹击中，飞船就会\u0026quot;爆炸\u0026rdquo;。我甚至将爆炸中的\u0026quot;碎片\u0026quot;也做成了可以击毁其他船只的活动物体，有时会引起有趣的连锁反应！\n本着原始游戏的精神，我使用模拟矢量图形对其进行了渲染，因此您可以执行诸如放大和缩小视图之类的操作，并且一切都会按比例放大/缩小。飞船本身是一堆矢量形式的线段，我在PARC的一些同事帮助我进行了设计，因此每个人的飞船都有独特的外观。\n基本上，如果一个东西需要实时数据流，又无需数据按照精确的时序传输，那么它就可以从RTP中受益。因此，除了音频和视频，我们还可以构建共享白板之类的东西。甚至使用RTP进行文件传输，尤其是与IP多播结合使用时。\n这就像BitTorrent，但是您不需要在对等方之间点对点地传输所有数据。原始的做种者可以立即将多播流发送到所有接收者，并且通过成功接收数据的任何对等方的重发，就可以快速解决传输中数据包丢失的问题。接收者甚至可以确定重传请求的范围，以便附近的一些对等方能够传递数据的副本，重传请求也可以被多播到该区域中的其他节点，因为网络中间的数据包丢失往往意味着下游有很多客户端错过了相同的数据。\n为什么您必须实现自己的视频压缩协议？当时没有其他可用的东西了吗？\n在我开始构建\u0026quot;nv\u0026quot;时，我所知道的唯一进行视频会议的系统是非常昂贵的专用硬件。例如，Steve Casner可以从BBN访问一个名为\u0026quot;DVC\u0026rdquo;（后来商品化为\u0026quot;PictureWindow\u0026rdquo;）的系统。压缩需要专用硬件，但是解压缩可以通过软件完成。\u0026ldquo;nv\u0026quot;之所以与众不同，是因为压缩和解压缩都是在软件中完成的，唯一的硬件要求是对输入的模拟视频信号进行数字化处理。\n当时，有关如何压缩视频的许多基本概念已经存在了，诸如MPEG-1标准之类的东西大约在\u0026quot;nv\u0026quot;出现的同时出现，但在当时绝对不可能使用MPEG-1进行实时编码。我所做的更改都是关于吸收这些基本概念并使用更便宜的算法对其进行近似模拟，其中我避免了余弦变换和浮点之类的事情，甚至避免了整数乘法，因为在SPARCstations上这些运算速度非常慢。我尽量只进行加/减法、位屏蔽和移位，这样可以使速度足够快，并使结果看起来仍像是视频。\n在\u0026quot;nv\u0026quot;发布的一两年之内，不仅是在MBONE网络上，还有其他地方（如Mac上的CU-SeeMe工具），都出现了许多不同的音视频工具可供选择。很明显的，实时视频的时机成熟了。事实上，我最终使\u0026quot;nv\u0026quot;与许多这些工具互操作，还有某些工具甚至采用了\u0026quot;nv\u0026quot;编解码器，以便在使用压缩方案时它们可以互操作。\nSDP #  ICE #  SRTP #  SCTP #  DTLS #  "});index.add({'id':10,'href':'/zh/docs/11-faq/','title':"常见问题",'section':"Docs",'content':"常见问题 #  为什么WebRTC使用UDP？ NAT穿透需要UDP。没有NAT穿透，就无法建立P2P连接。UDP不像TCP那样\u0026quot;保证送达\u0026rdquo;，因此WebRTC在用户级别提供这一特性。\n要了解更多信息，请参考 连接 章节。\n  数据通道最多可以有几个？ 因为流标识符有16位，所以最多有65536个通道。您可以随时关闭再创建一个新的。   WebRTC是否有带宽限制？ 数据通道和RTP都使用拥塞控制。这意味着WebRTC会主动测量您的带宽并尝试使用最佳数值。这是一种平衡措施，这样可以尽量发送数据，而不会使网络连接过载。   我可以发送二进制数据吗？ 是的，您可以通过数据通道发送文本和二进制数据。   WebRTC延迟怎么样？ 对于未作调整的媒体，估计不到500毫秒。如果您愿意为延迟调整或牺牲音质/画质，有开发人员将延迟降到了100ms以下。\n数据通道支持\u0026quot;部分可靠性\u0026quot;选项，该选项可以减少由于有损连接上的数据重传而引起的延迟。如果配置正确的话，速度可以超过TCP TLS连接。\n  什么情况下我会需要无序交付的数据通道？ 有时，新的信息会淘汰旧的信息（例如对象的位置信息）；或者，每个消息都是彼此独立的，并且您需要避免行头阻塞延迟。   我可以通过数据通道发送音频或视频吗？ 您可以通过数据通道发送任何数据。如果是在浏览器中这样使用，您就需要自行对数据进行解码，然后将其传递给媒体播放器进行渲染；在使用媒体通道时，这部分是自动完成的。   "});})();