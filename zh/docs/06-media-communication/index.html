<!doctype html><html lang=zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="我可以从WebRTC的媒体通信中得到什么？ #  WebRTC允许您发送和接收无限多条音频和视频流。您可以在通话期间随时添加和删除这些流。这些流可以全部独立，也可以捆绑在一起！您甚至可以将网络摄像头的音频/视频放到您桌面的视频流中，然后将此视频流以feed的形式发送出去。
WebRTC协议与编解码器无关。底层传输支持所有格式的内容，即使是还不存在的格式！ 但是，您正与之通信的WebRTC代理可能没有必要的工具来接受它。
WebRTC针对动态网络状况也有对应的处理方案。在通话过程中，带宽可能会增加或减少。 甚至可能突然间大量丢包。该协议对所有这类问题的处理都做了相应的设计。WebRTC根据网络状况作出响应，并尝试利用可用资源为您提供最佳体验。
它是如何工作的？ #  WebRTC使用RFC 1889中定义的两个既有协议RTP和RTCP。
RTP（实时传输协议/Real-time Transport Protocol）是承载媒体的协议。它为视频的实时传输而设计。它没有规定有关延迟或可靠性的任何规则，但是为您提供了实现这些规则的工具。RTP提供了流的设计，因此您可以通过一个连接发布多个媒体源。它还为您提供了完善媒体传递途径所需的计时和排序信息。
RTCP（RTP控制协议/RTP Control Protocol）是用于传达有关呼叫的元数据的协议。其格式非常灵活，并允许您可以添加所需的任何元数据。这点被用来传达有关呼叫的统计信息。也是处理分组丢失和实现拥塞控制的必备特性。它为您提供了响应变化的网络状况所必需的双向通信能力。
延迟与质量 #  实时媒体就是要在延迟和质量之间进行权衡。您愿意忍受的延迟时间越长，可以预期的视频质量就越高。
现实世界的局限性 #  下面这些限制都是由现实世界的局限性引起的。它们都是您需要考虑的网络特性。
带宽 #  带宽是可以在给定路径上传输的最大数据速率。注意这不是一个静态数字，这一点很重要。随着越来越多（或越少）的人使用路由，带宽将发生变化。
当您尝试发送的数据超过可用带宽时，您将遇到网络拥塞的情况。
传输时间 #  传输时间指的是一个数据包到达目标需要多长时间。像带宽一样，这不是常量。传输时间随时可能波动。
抖动 #  抖动是传输时间可能会变化导致的现象。有时您会看到收到的数据包突然爆炸式增加。网络路径上的任何硬件都可能引入这个问题。
数据包丢失 #  数据包丢失是指消息在传输中丢失。丢失率可能是稳定的，也可能突然增加。这也是一个常见的情况，特别是在无线网络上！
最大传输单位（Maximum transmission unit/MTU） #  最大传输单位是指单个数据包的最大限制。您无法在网络上发送一个巨大的消息。在协议级别上，您需要将数据分成多个小数据包。
根据您采用的网络路径，MTU也将有所不同。您可以使用Path MTU Discovery之类的协议来确定可以发送的最大的数据包大小。
Media 101（媒体格式基础知识） #  Codec（编解码器） #  Frame Types（帧类型） #  RTP #  Packet Format（包格式） #  每个RTP数据包都具有以下结构："><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="媒体通信"><meta property="og:description" content="我可以从WebRTC的媒体通信中得到什么？ #  WebRTC允许您发送和接收无限多条音频和视频流。您可以在通话期间随时添加和删除这些流。这些流可以全部独立，也可以捆绑在一起！您甚至可以将网络摄像头的音频/视频放到您桌面的视频流中，然后将此视频流以feed的形式发送出去。
WebRTC协议与编解码器无关。底层传输支持所有格式的内容，即使是还不存在的格式！ 但是，您正与之通信的WebRTC代理可能没有必要的工具来接受它。
WebRTC针对动态网络状况也有对应的处理方案。在通话过程中，带宽可能会增加或减少。 甚至可能突然间大量丢包。该协议对所有这类问题的处理都做了相应的设计。WebRTC根据网络状况作出响应，并尝试利用可用资源为您提供最佳体验。
它是如何工作的？ #  WebRTC使用RFC 1889中定义的两个既有协议RTP和RTCP。
RTP（实时传输协议/Real-time Transport Protocol）是承载媒体的协议。它为视频的实时传输而设计。它没有规定有关延迟或可靠性的任何规则，但是为您提供了实现这些规则的工具。RTP提供了流的设计，因此您可以通过一个连接发布多个媒体源。它还为您提供了完善媒体传递途径所需的计时和排序信息。
RTCP（RTP控制协议/RTP Control Protocol）是用于传达有关呼叫的元数据的协议。其格式非常灵活，并允许您可以添加所需的任何元数据。这点被用来传达有关呼叫的统计信息。也是处理分组丢失和实现拥塞控制的必备特性。它为您提供了响应变化的网络状况所必需的双向通信能力。
延迟与质量 #  实时媒体就是要在延迟和质量之间进行权衡。您愿意忍受的延迟时间越长，可以预期的视频质量就越高。
现实世界的局限性 #  下面这些限制都是由现实世界的局限性引起的。它们都是您需要考虑的网络特性。
带宽 #  带宽是可以在给定路径上传输的最大数据速率。注意这不是一个静态数字，这一点很重要。随着越来越多（或越少）的人使用路由，带宽将发生变化。
当您尝试发送的数据超过可用带宽时，您将遇到网络拥塞的情况。
传输时间 #  传输时间指的是一个数据包到达目标需要多长时间。像带宽一样，这不是常量。传输时间随时可能波动。
抖动 #  抖动是传输时间可能会变化导致的现象。有时您会看到收到的数据包突然爆炸式增加。网络路径上的任何硬件都可能引入这个问题。
数据包丢失 #  数据包丢失是指消息在传输中丢失。丢失率可能是稳定的，也可能突然增加。这也是一个常见的情况，特别是在无线网络上！
最大传输单位（Maximum transmission unit/MTU） #  最大传输单位是指单个数据包的最大限制。您无法在网络上发送一个巨大的消息。在协议级别上，您需要将数据分成多个小数据包。
根据您采用的网络路径，MTU也将有所不同。您可以使用Path MTU Discovery之类的协议来确定可以发送的最大的数据包大小。
Media 101（媒体格式基础知识） #  Codec（编解码器） #  Frame Types（帧类型） #  RTP #  Packet Format（包格式） #  每个RTP数据包都具有以下结构："><meta property="og:type" content="article"><meta property="og:url" content="https://webrtcforthecurious.com/zh/docs/06-media-communication/"><meta property="article:modified_time" content="2021-03-01T18:10:32+08:00"><meta property="og:site_name" content="给好奇者的WebRTC"><title>媒体通信 | 给好奇者的WebRTC</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/06-media-communication/ title="Media Communication"><link rel=alternate hreflang=tr href=https://webrtcforthecurious.com/tr/docs/06-media-communication/ title="Media Communication"><link rel=stylesheet href=/book.min.6cd8553a6854f4812343f0f0c8baca31271e686434f381fbe3c7226f66639176.css integrity="sha256-bNhVOmhU9IEjQ/DwyLrKMSceaGQ084H748cib2ZjkXY="><script defer src=/zh.search.min.9da0e0c9e811421630eb5c26f62a8bbf95b534dcd272128eefa8829004db3c3d.js integrity="sha256-naDgyegRQhYw61wm9iqLv5W1NNzSchKO76iCkATbPD0="></script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/zh><span>给好奇者的WebRTC</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/zh/docs/01-what-why-and-how/>是什么，为什么，如何使用</a></li><li><a href=/zh/docs/02-signaling/>信令</a></li><li><a href=/zh/docs/03-connecting/>连接</a></li><li><a href=/zh/docs/04-securing/>安全性</a></li><li><a href=/zh/docs/05-real-time-networking/>实时联网</a></li><li><a href=/zh/docs/06-media-communication/ class=active>媒体通信</a></li><li><a href=/zh/docs/07-data-communication/>数据通信</a></li><li><a href=/zh/docs/08-applied-webrtc/>WebRTC应用场景</a></li><li><a href=/zh/docs/09-debugging/>调试</a></li><li><a href=/zh/docs/10-history-of-webrtc/>历史</a></li><li><a href=/zh/docs/11-faq/>常见问题</a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>媒体通信</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#它是如何工作的>它是如何工作的？</a></li><li><a href=#延迟与质量>延迟与质量</a><ul><li><a href=#现实世界的局限性>现实世界的局限性</a></li></ul></li><li><a href=#media-101媒体格式基础知识>Media 101（媒体格式基础知识）</a><ul><li><a href=#codec编解码器>Codec（编解码器）</a></li><li><a href=#frame-types帧类型>Frame Types（帧类型）</a></li></ul></li><li><a href=#rtp>RTP</a><ul><li><a href=#packet-format包格式>Packet Format（包格式）</a></li><li><a href=#extensions扩展>Extensions（扩展）</a></li><li><a href=#mapping-payload-types-to-codecs将负载类型映射到编解码器>Mapping Payload Types to Codecs（将负载类型映射到编解码器）</a></li></ul></li><li><a href=#rtcp>RTCP</a><ul><li><a href=#packet-format>Packet Format</a></li><li><a href=#full-intra-frame-request完整的帧内请求>Full INTRA-frame Request（完整的帧内请求）</a></li><li><a href=#negative-acknowledgements否定确认>Negative ACKnowledgements（否定确认）</a></li><li><a href=#senderreceiver-reports发送方接收方报告>Sender/Receiver Reports（发送方/接收方报告）</a></li><li><a href=#generic-rtp-feedback通用rtp反馈>Generic RTP Feedback（通用RTP反馈）</a></li></ul></li><li><a href=#rtprtcp是如何解决问题的>RTP/RTCP是如何解决问题的</a><ul><li><a href=#negative-acknowledgment否定确认>Negative Acknowledgment（否定确认）</a></li><li><a href=#forward-error-correction前向纠错>Forward Error Correction（前向纠错）</a></li><li><a href=#自适应比特率和带宽估计>自适应比特率和带宽估计</a></li><li><a href=#congestion-control拥塞控制>Congestion Control（拥塞控制）</a></li><li><a href=#jitterbuffer抖动缓冲>JitterBuffer（抖动缓冲）</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=我可以从webrtc的媒体通信中得到什么>我可以从WebRTC的媒体通信中得到什么？
<a class=anchor href=#%e6%88%91%e5%8f%af%e4%bb%a5%e4%bb%8ewebrtc%e7%9a%84%e5%aa%92%e4%bd%93%e9%80%9a%e4%bf%a1%e4%b8%ad%e5%be%97%e5%88%b0%e4%bb%80%e4%b9%88>#</a></h1><p>WebRTC允许您发送和接收无限多条音频和视频流。您可以在通话期间随时添加和删除这些流。这些流可以全部独立，也可以捆绑在一起！您甚至可以将网络摄像头的音频/视频放到您桌面的视频流中，然后将此视频流以feed的形式发送出去。</p><p>WebRTC协议与编解码器无关。底层传输支持所有格式的内容，即使是还不存在的格式！ 但是，您正与之通信的WebRTC代理可能没有必要的工具来接受它。</p><p>WebRTC针对动态网络状况也有对应的处理方案。在通话过程中，带宽可能会增加或减少。 甚至可能突然间大量丢包。该协议对所有这类问题的处理都做了相应的设计。WebRTC根据网络状况作出响应，并尝试利用可用资源为您提供最佳体验。</p><h2 id=它是如何工作的>它是如何工作的？
<a class=anchor href=#%e5%ae%83%e6%98%af%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c%e7%9a%84>#</a></h2><p>WebRTC使用<a href=https://tools.ietf.org/html/rfc1889>RFC 1889</a>中定义的两个既有协议RTP和RTCP。</p><p>RTP（实时传输协议/Real-time Transport Protocol）是承载媒体的协议。它为视频的实时传输而设计。它没有规定有关延迟或可靠性的任何规则，但是为您提供了实现这些规则的工具。RTP提供了流的设计，因此您可以通过一个连接发布多个媒体源。它还为您提供了完善媒体传递途径所需的计时和排序信息。</p><p>RTCP（RTP控制协议/RTP Control Protocol）是用于传达有关呼叫的元数据的协议。其格式非常灵活，并允许您可以添加所需的任何元数据。这点被用来传达有关呼叫的统计信息。也是处理分组丢失和实现拥塞控制的必备特性。它为您提供了响应变化的网络状况所必需的双向通信能力。</p><h2 id=延迟与质量>延迟与质量
<a class=anchor href=#%e5%bb%b6%e8%bf%9f%e4%b8%8e%e8%b4%a8%e9%87%8f>#</a></h2><p>实时媒体就是要在延迟和质量之间进行权衡。您愿意忍受的延迟时间越长，可以预期的视频质量就越高。</p><h3 id=现实世界的局限性>现实世界的局限性
<a class=anchor href=#%e7%8e%b0%e5%ae%9e%e4%b8%96%e7%95%8c%e7%9a%84%e5%b1%80%e9%99%90%e6%80%a7>#</a></h3><p>下面这些限制都是由现实世界的局限性引起的。它们都是您需要考虑的网络特性。</p><h4 id=带宽>带宽
<a class=anchor href=#%e5%b8%a6%e5%ae%bd>#</a></h4><p>带宽是可以在给定路径上传输的最大数据速率。注意这不是一个静态数字，这一点很重要。随着越来越多（或越少）的人使用路由，带宽将发生变化。</p><p>当您尝试发送的数据超过可用带宽时，您将遇到网络拥塞的情况。</p><h4 id=传输时间>传输时间
<a class=anchor href=#%e4%bc%a0%e8%be%93%e6%97%b6%e9%97%b4>#</a></h4><p>传输时间指的是一个数据包到达目标需要多长时间。像带宽一样，这不是常量。传输时间随时可能波动。</p><h4 id=抖动>抖动
<a class=anchor href=#%e6%8a%96%e5%8a%a8>#</a></h4><p>抖动是<code>传输时间</code>可能会变化导致的现象。有时您会看到收到的数据包突然爆炸式增加。网络路径上的任何硬件都可能引入这个问题。</p><h4 id=数据包丢失>数据包丢失
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e5%8c%85%e4%b8%a2%e5%a4%b1>#</a></h4><p>数据包丢失是指消息在传输中丢失。丢失率可能是稳定的，也可能突然增加。这也是一个常见的情况，特别是在无线网络上！</p><h4 id=最大传输单位maximum-transmission-unitmtu>最大传输单位（Maximum transmission unit/MTU）
<a class=anchor href=#%e6%9c%80%e5%a4%a7%e4%bc%a0%e8%be%93%e5%8d%95%e4%bd%8dmaximum-transmission-unitmtu>#</a></h4><p>最大传输单位是指单个数据包的最大限制。您无法在网络上发送一个巨大的消息。在协议级别上，您需要将数据分成多个小数据包。</p><p>根据您采用的网络路径，MTU也将有所不同。您可以使用<a href=https://tools.ietf.org/html/rfc1191>Path MTU Discovery</a>之类的协议来确定可以发送的最大的数据包大小。</p><h2 id=media-101媒体格式基础知识>Media 101（媒体格式基础知识）
<a class=anchor href=#media-101%e5%aa%92%e4%bd%93%e6%a0%bc%e5%bc%8f%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86>#</a></h2><h3 id=codec编解码器>Codec（编解码器）
<a class=anchor href=#codec%e7%bc%96%e8%a7%a3%e7%a0%81%e5%99%a8>#</a></h3><h3 id=frame-types帧类型>Frame Types（帧类型）
<a class=anchor href=#frame-types%e5%b8%a7%e7%b1%bb%e5%9e%8b>#</a></h3><h2 id=rtp>RTP
<a class=anchor href=#rtp>#</a></h2><h3 id=packet-format包格式>Packet Format（包格式）
<a class=anchor href=#packet-format%e5%8c%85%e6%a0%bc%e5%bc%8f>#</a></h3><p>每个RTP数据包都具有以下结构：</p><pre><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|V=2|P|X|  CC   |M|     PT      |       Sequence Number         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           Timestamp                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Synchronization Source (SSRC) identifier            |
+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
|            Contributing Source (CSRC) identifiers             |
|                             ....                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            Payload                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><h4 id=version-v>Version (V)
<a class=anchor href=#version-v>#</a></h4><p><code>Version</code>总是<code>2</code>。</p><h4 id=padding-p>Padding (P)
<a class=anchor href=#padding-p>#</a></h4><p><code>Padding</code>是控制有效载荷是否具有填充值的布尔值。</p><p>有效负载的最后一个字节包含添加了多少填充字节的计数。</p><h4 id=extension-x>Extension (X)
<a class=anchor href=#extension-x>#</a></h4><p>如果设置的话，RTP报头将有扩展段（可选）。这点将在下面更详细地描述。</p><h4 id=csrc-count-cc>CSRC count (CC)
<a class=anchor href=#csrc-count-cc>#</a></h4><p>在<code>SSRC</code>之后，有效负载之前的<code>CSRC</code>标识符的数量。</p><h4 id=marker-m>Marker (M)
<a class=anchor href=#marker-m>#</a></h4><p>标记位没有预设含义，由用户决定。</p><p>在某些情况下，它是在用户讲话时设置的。它还通常用于标记关键帧。</p><h4 id=payload-type-pt>Payload Type (PT)
<a class=anchor href=#payload-type-pt>#</a></h4><p><code>Payload Type</code>（负载类型）是此数据包所承载的编解码器的一个唯一标识符。</p><p>对于WebRTC，<code>Payload Type</code>是动态的。一个呼叫中的VP8的PT可能与另一个呼叫中的不同。呼叫中的Offerer确定<code>Payload Type</code>到<code>Session Description</code>（会话描述符）中的编解码器的映射。</p><h4 id=sequence-number>Sequence Number
<a class=anchor href=#sequence-number>#</a></h4><p><code>Sequence Number</code>（序列号）用于对流中的数据包进行排序。每次发送数据包时，<code>Sequence Number</code>都会增加1。</p><p>RTP被设计为可以在有损网络上使用。这为接收器提供了一种检测数据包何时丢失的方法。</p><h4 id=timestamp>Timestamp
<a class=anchor href=#timestamp>#</a></h4><p>此数据包的采样时刻。这不是全局时钟，而是在当前媒体流中所经过的时间。</p><h4 id=synchronization-source-ssrc>Synchronization Source (SSRC)
<a class=anchor href=#synchronization-source-ssrc>#</a></h4><p><code>SSRC</code>是此流的唯一标识符。 这使您可以在单个流上传输多个媒体流。</p><h4 id=contributing-source-csrc>Contributing Source (CSRC)
<a class=anchor href=#contributing-source-csrc>#</a></h4><p>一个列表，用于表示哪些<code>SSRC</code>参与到了这个数据包中。</p><p>这通常用于语音指示器。假设在服务器端，您将多个音频源组合到一个单独的RTP流中。然后，您可以在此字段中表示<code>输入流A和C此时正在讲话</code>。</p><h4 id=payload>Payload
<a class=anchor href=#payload>#</a></h4><p>实际有效负载数据。如果设置了填充（padding）标记，则可能以添加的填充字节数结尾。</p><h3 id=extensions扩展>Extensions（扩展）
<a class=anchor href=#extensions%e6%89%a9%e5%b1%95>#</a></h3><h3 id=mapping-payload-types-to-codecs将负载类型映射到编解码器>Mapping Payload Types to Codecs（将负载类型映射到编解码器）
<a class=anchor href=#mapping-payload-types-to-codecs%e5%b0%86%e8%b4%9f%e8%bd%bd%e7%b1%bb%e5%9e%8b%e6%98%a0%e5%b0%84%e5%88%b0%e7%bc%96%e8%a7%a3%e7%a0%81%e5%99%a8>#</a></h3><h2 id=rtcp>RTCP
<a class=anchor href=#rtcp>#</a></h2><h3 id=packet-format>Packet Format
<a class=anchor href=#packet-format>#</a></h3><p>每个RTCP数据包都具有以下结构：</p><pre><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|V=2|P|    RC   |       PT      |             length            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            Payload                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><h4 id=version-v-1>Version (V)
<a class=anchor href=#version-v-1>#</a></h4><p><code>Version</code>总是<code>2</code>。</p><h4 id=padding-p-1>Padding (P)
<a class=anchor href=#padding-p-1>#</a></h4><p><code>Padding</code>是控制有效载荷是否具有填充值的布尔值。</p><p>有效负载的最后一个字节包含添加了多少填充字节的计数。</p><h4 id=reception-report-count-rc>Reception Report Count (RC)
<a class=anchor href=#reception-report-count-rc>#</a></h4><p>此数据包中的报告数。单个RTCP数据包可以包含多个事件。</p><h4 id=packet-type-pt>Packet Type (PT)
<a class=anchor href=#packet-type-pt>#</a></h4><p>指示RTCP数据包类型的唯一标识符。WebRTC代理不需要支持所有这些类型，并且代理之间的支持能力可以是不同的。下面这些是您可能经常看到的类型。</p><ul><li>完整的帧内请求（FIR）-<code>192</code></li><li>否定确认（NACK）-<code>193</code></li><li>发送方报告-<code>200</code></li><li>接收方报告-<code>201</code></li><li>通用RTP反馈-<code>205</code></li></ul><p>这些分组类型的意义将在下面更详细地描述。</p><h3 id=full-intra-frame-request完整的帧内请求>Full INTRA-frame Request（完整的帧内请求）
<a class=anchor href=#full-intra-frame-request%e5%ae%8c%e6%95%b4%e7%9a%84%e5%b8%a7%e5%86%85%e8%af%b7%e6%b1%82>#</a></h3><p>此RTCP消息通知发送者它需要发送完整图像。这适用于编码器为您提供了帧的一部分，但您无法对其进行解码的情况。</p><p>之所以会发生这种情况，是因为您有很多数据包丢失，或者解码器崩溃了。</p><h3 id=negative-acknowledgements否定确认>Negative ACKnowledgements（否定确认）
<a class=anchor href=#negative-acknowledgements%e5%90%a6%e5%ae%9a%e7%a1%ae%e8%ae%a4>#</a></h3><p>NACK请求发送方重新发送单个RTP数据包。这通常是由于RTP数据包丢失而引起的，但是也可能由于延迟而发生。</p><p>与请求重新发送整个帧相比，NACK的带宽效率要高得多。由于RTP将数据包分解成很小的块，因此您实际上只是在请求丢失的一个很小的部分。</p><h3 id=senderreceiver-reports发送方接收方报告>Sender/Receiver Reports（发送方/接收方报告）
<a class=anchor href=#senderreceiver-reports%e5%8f%91%e9%80%81%e6%96%b9%e6%8e%a5%e6%94%b6%e6%96%b9%e6%8a%a5%e5%91%8a>#</a></h3><p>这些报告用于在代理之间发送统计信息。它传达了实际接收到的和抖动的数据包数量。</p><p>这些报告可用于诊断或者基本的拥塞控制。</p><h3 id=generic-rtp-feedback通用rtp反馈>Generic RTP Feedback（通用RTP反馈）
<a class=anchor href=#generic-rtp-feedback%e9%80%9a%e7%94%a8rtp%e5%8f%8d%e9%a6%88>#</a></h3><h2 id=rtprtcp是如何解决问题的>RTP/RTCP是如何解决问题的
<a class=anchor href=#rtprtcp%e6%98%af%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3%e9%97%ae%e9%a2%98%e7%9a%84>#</a></h2><p>RTP和RTCP需要协同解决网络引起的所有问题。这些技术仍在不断进化中！</p><h3 id=negative-acknowledgment否定确认>Negative Acknowledgment（否定确认）
<a class=anchor href=#negative-acknowledgment%e5%90%a6%e5%ae%9a%e7%a1%ae%e8%ae%a4>#</a></h3><p>也称为NACK。这是使用RTP处理数据包丢失的一种方法。</p><p>NACK是回给发送方以请求重发的RTCP消息。接收方使用SSRC和序列号制作RTCP消息。如果发送方没有可用于重新发送的RTP数据包，则忽略该消息。</p><h3 id=forward-error-correction前向纠错>Forward Error Correction（前向纠错）
<a class=anchor href=#forward-error-correction%e5%89%8d%e5%90%91%e7%ba%a0%e9%94%99>#</a></h3><p>简称为FEC。处理丢包的另一种方法。FEC指的是发送方多次重复发送相同的数据，甚至是在接收方没有要求的情况下发送。这是在RTP协议层级完成的，甚至也可以在编解码器以下的层级完成。</p><p>在呼叫的数据丢包率比较稳定的情况下，作为延迟处理方案，FEC比NACK好的多。对于NACK，必须先请求，然后重新传输数据包，数据往返的时间对性能的影响可能是很明显的。</p><h3 id=自适应比特率和带宽估计>自适应比特率和带宽估计
<a class=anchor href=#%e8%87%aa%e9%80%82%e5%ba%94%e6%af%94%e7%89%b9%e7%8e%87%e5%92%8c%e5%b8%a6%e5%ae%bd%e4%bc%b0%e8%ae%a1>#</a></h3><p>现代IP网络（包括无线和有线网络）的一个普遍问题是不可预测和不可靠的带宽。在整个会话过程中，网络条件可能会多次动态变化。在一秒钟之内看到可用的带宽急剧变化（差别达到数量级），这样的情况并不少见。</p><p>有线网络的不可预测性可能是由于网络带宽需求的变化，路由更改，传输介质（光纤通道，以太网，dsl）的限制等引起的。</p><p>除了在有线网络中存在的问题之外，无线电信号传输本身的特性，来自多个源的干扰，到手机信号塔或Wi-Fi接入点的距离以及物理障碍（阅读墙）也是导致无线网络特征无法预测的一些原因。</p><p>WebRTC具有多种机制，即使网络条件发生变化，也可以帮助将视频/音频信号顺利发送给接收方。
其主要思路是根据预测的，当前的和将来的可用网络带宽来调整编码比特率。
这样可以确保传输质量最佳的视频/音频信号，并且不会因为网络拥塞而断开连接。
对网络行为建模并尝试对其进行预测的启发式方法称为带宽估计。</p><h4 id=rembreceiver-estimated-maximum-bitrate接收方估计的最大比特率>REMB（Receiver Estimated Maximum Bitrate/接收方估计的最大比特率）
<a class=anchor href=#rembreceiver-estimated-maximum-bitrate%e6%8e%a5%e6%94%b6%e6%96%b9%e4%bc%b0%e8%ae%a1%e7%9a%84%e6%9c%80%e5%a4%a7%e6%af%94%e7%89%b9%e7%8e%87>#</a></h4><p>一种曾被广泛应用，却从未被完整标准化，现在被认为已弃用的方法，叫做<a href=https://tools.ietf.org/html/draft-alvestrand-rmcat-remb-03>REMB</a> (接收方估计的最大比特率)。
REMB是接收方发给发送方的特殊RTCP数据包，用来通知发送方可用的带宽。对于估计REMB相关的带宽问题，没有标准的方法定义（存疑），因此实际的带宽值是跟不同实现相关的。研究REMB细节的一个很好的起点是<a href=https://source.chromium.org/chromium/chromium/src/+/master:third_party/webrtc/modules/rtp_rtcp/source/rtcp_packet/remb.cc>Chrome源码</a>。</p><p>数据包中唯一有用的负载是比特率，以每秒比特数为单位。
造成明显的歧义和混淆的根源是，REMB中的比特率被定义为 <em>total（全部的）</em> 比特率，而WebRTC库通常仅仅使用它来限制视频编码。</p><p><figure><img src=/images/05-remb.png></figure><img src=../images/05-remb.png alt=REMB></p><h3 id=congestion-control拥塞控制>Congestion Control（拥塞控制）
<a class=anchor href=#congestion-control%e6%8b%a5%e5%a1%9e%e6%8e%a7%e5%88%b6>#</a></h3><p>经验丰富的WebRTC业内人士<a href=https://gstconf.ubicast.tv/videos/google-transport-wide-congestion-control/>声称</a>，用REMB的方式（实现拥塞控制），给WebRTC只留下了伤疤，愤怒的表情，乃至Google工程师的耻笑。</p><p>拥塞控制是根据网络属性调整媒体的行为。如果带宽较小，则需要发送质量较低的视频。</p><p>拥塞控制通过提供更细粒度的控制以及对网络连接和状况的监视来改善WebRTC体验。</p><h4 id=twcctransport-wide-congestion-control传输范围内的拥塞控制>TWCC（Transport-Wide Congestion Control/传输范围内的拥塞控制）
<a class=anchor href=#twcctransport-wide-congestion-control%e4%bc%a0%e8%be%93%e8%8c%83%e5%9b%b4%e5%86%85%e7%9a%84%e6%8b%a5%e5%a1%9e%e6%8e%a7%e5%88%b6>#</a></h4><p>传输范围内的拥塞控制（TWCC）是在大多数浏览器中实现的高级拥塞控制规范。</p><p>TWCC使用一个非常简单的原则：</p><p><figure><img src=/images/05-twcc-idea.png></figure><img src=../images/05-twcc-idea.png alt=TWCC></p><p>与REMB不同，TWCC的接收方不会尝试估计自己的传入比特率。它只是让发送方知道哪些包在何处及何时被接收。基于这些报告，发送方可以了解网络的最新的状况。</p><ul><li>发送方创建带有特殊的TWCC标头扩展的RTP数据包，其中包含一个数据包序列号的列表。</li><li>接收方以特殊的RTCP反馈消息进行响应，以使发送方知道每个数据包是否以及何时被接收。</li></ul><p>发送方跟踪已发送的数据包，包括它们的序列号，大小和时间戳。
当发送方从接收方收到RTCP消息时，它将发送数据包间的延迟与接收延迟进行比较。
如果接收延迟增加，则意味着网络正在发生拥塞，发送者必须对此采取行动。</p><p>在下图中，数据包间延迟的中位数增长了+20毫秒，这清楚地表明网络正在发生拥塞。</p><p><figure><img src=/images/05-twcc.png></figure><img src=../images/05-twcc.png alt=TWCC></p><p>TWCC提供了原始数据和实时网络状况的绝佳视图：</p><ul><li>几乎是即时的丢包统计信息，不仅包括丢失的百分比，还包括丢失的确切数据包。</li><li>准确的发送比特率。</li><li>准确的接收比特率。</li><li>抖动估计。</li><li>发送和接收数据包延迟之间的差异。</li></ul><p>一种简单的，用于估计从发送方到接收方的传输比特率的拥塞控制算法是，将接收到的数据包大小相加，然后将其除以接收方一端经过的时间。</p><p>更复杂的拥塞控制算法建立在原始的TWCC数据的基础上，例如：<a href=https://tools.ietf.org/html/draft-alvestrand-rmcat-congestion-02>一种用于实时通信的Google拥塞控制算法</a>，简称GCC，由Google提出并在Chrome中实现。
它通过使用<a href=https://en.wikipedia.org/wiki/Kalman_filter>Kalman过滤器</a>预测当前和将来的网络带宽。</p><p>还有几种GCC的替代品，例如：<a href=https://tools.ietf.org/html/draft-zhu-rmcat-nada-04>NADA：一种实时媒体的统一拥塞控制方案</a> 和 <a href=https://tools.ietf.org/html/draft-johansson-rmcat-scream-cc-05>SCReAM- 多媒体的自时钟速率自适应</a>。</p><p><strong>问</strong>：我如何知道TWCC已被支持并启用？</p><p><strong>答</strong>：查看SDP offer/answer。如果您看到以下几行，则说明您的连接已经协商并启用了TWCC：</p><pre><code>a=extmap:5 http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions
</code></pre><p>以及</p><pre><code>a=rtcp-fb:96 transport-cc
</code></pre><h3 id=jitterbuffer抖动缓冲>JitterBuffer（抖动缓冲）
<a class=anchor href=#jitterbuffer%e6%8a%96%e5%8a%a8%e7%bc%93%e5%86%b2>#</a></h3></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div class=book-languages tabindex=0 aria-haspopup=true><ul><li class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
简体中文</li></ul><ul class=book-languages-list><li><a href=https://webrtcforthecurious.com/docs/06-media-communication/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
English</a></li><li><a href=https://webrtcforthecurious.com/tr/docs/06-media-communication/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Turkish</a></li><li><a href=https://webrtcforthecurious.com/fa/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Persian</a></li><li class=active><a href=https://webrtcforthecurious.com/zh/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
简体中文</a></li></ul></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/03170d9f152cbb92aae773c54563736c1623b6bd title="最后修改者 Cliff Han | March 1, 2021" target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>March 1, 2021</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/content.zh-cn/docs/06-media-communication.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>编辑本页</span></a></div></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#它是如何工作的>它是如何工作的？</a></li><li><a href=#延迟与质量>延迟与质量</a><ul><li><a href=#现实世界的局限性>现实世界的局限性</a></li></ul></li><li><a href=#media-101媒体格式基础知识>Media 101（媒体格式基础知识）</a><ul><li><a href=#codec编解码器>Codec（编解码器）</a></li><li><a href=#frame-types帧类型>Frame Types（帧类型）</a></li></ul></li><li><a href=#rtp>RTP</a><ul><li><a href=#packet-format包格式>Packet Format（包格式）</a></li><li><a href=#extensions扩展>Extensions（扩展）</a></li><li><a href=#mapping-payload-types-to-codecs将负载类型映射到编解码器>Mapping Payload Types to Codecs（将负载类型映射到编解码器）</a></li></ul></li><li><a href=#rtcp>RTCP</a><ul><li><a href=#packet-format>Packet Format</a></li><li><a href=#full-intra-frame-request完整的帧内请求>Full INTRA-frame Request（完整的帧内请求）</a></li><li><a href=#negative-acknowledgements否定确认>Negative ACKnowledgements（否定确认）</a></li><li><a href=#senderreceiver-reports发送方接收方报告>Sender/Receiver Reports（发送方/接收方报告）</a></li><li><a href=#generic-rtp-feedback通用rtp反馈>Generic RTP Feedback（通用RTP反馈）</a></li></ul></li><li><a href=#rtprtcp是如何解决问题的>RTP/RTCP是如何解决问题的</a><ul><li><a href=#negative-acknowledgment否定确认>Negative Acknowledgment（否定确认）</a></li><li><a href=#forward-error-correction前向纠错>Forward Error Correction（前向纠错）</a></li><li><a href=#自适应比特率和带宽估计>自适应比特率和带宽估计</a></li><li><a href=#congestion-control拥塞控制>Congestion Control（拥塞控制）</a></li><li><a href=#jitterbuffer抖动缓冲>JitterBuffer（抖动缓冲）</a></li></ul></li></ul></nav></aside></main></body></html>